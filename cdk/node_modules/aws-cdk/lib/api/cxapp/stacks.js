"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const renames_1 = require("../../renames");
const cdkUtil = require("../../util");
const toposort_1 = require("../util/toposort");
/**
 * Routines to get stacks from an app
 *
 * In a class because it shares some global state
 */
class AppStacks {
    constructor(props) {
        this.props = props;
        this.renames = props.renames || new renames_1.Renames({});
    }
    /**
     * List all stacks in the CX and return the selected ones
     *
     * It's an error if there are no stacks to select, or if one of the requested parameters
     * refers to a nonexistant stack.
     */
    async selectStacks(selectors, extendedSelection) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        const stacks = await this.listStacks();
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            logging_1.debug('Stack name not specified, so defaulting to all available stacks: ' + listStackNames(stacks));
            return this.applyRenames(stacks);
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.name, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                if (minimatch(stack.name, pattern) && !selectedStacks.has(stack.name)) {
                    selectedStacks.set(stack.name, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        switch (extendedSelection) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.name));
        // Only check selected stacks for errors
        this.processMessages(selectedList);
        return this.applyRenames(selectedList);
    }
    /**
     * Return all stacks in the CX
     *
     * If the stacks have dependencies between them, they will be returned in
     * topologically sorted order. If there are dependencies that are not in the
     * set, they will be ignored; it is the user's responsibility that the
     * non-selected stacks have already been deployed previously.
     *
     * Renames are *NOT* applied in list mode.
     */
    async listStacks() {
        const response = await this.synthesizeStacks();
        return toposort_1.topologicalSort(response.stacks, s => s.name, s => s.dependsOn || []);
    }
    /**
     * Synthesize a single stack
     */
    async synthesizeStack(stackName) {
        const resp = await this.synthesizeStacks();
        const stack = resp.stacks.find(s => s.name === stackName);
        if (!stack) {
            throw new Error(`Stack ${stackName} not found`);
        }
        return this.applyRenames([stack])[0];
    }
    /**
     * Synthesize a set of stacks
     */
    async synthesizeStacks() {
        if (this.cachedResponse) {
            return this.cachedResponse;
        }
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        while (true) {
            const response = await this.props.synthesizer(this.props.aws, this.props.configuration);
            const allMissing = cdkUtil.deepMerge(...response.stacks.map(s => s.missing));
            if (!cdkUtil.isEmpty(allMissing)) {
                logging_1.debug(`Some context information is missing. Fetching...`);
                await contextproviders.provideContextValues(allMissing, this.props.configuration.context, this.props.aws);
                // Cache the new context to disk
                await this.props.configuration.saveContext();
                continue;
            }
            if (trackVersions && response.runtime) {
                const modules = formatModules(response.runtime);
                for (const stack of response.stacks) {
                    if (!stack.template.Resources) {
                        stack.template.Resources = {};
                    }
                    if (!stack.template.Resources.CDKMetadata) {
                        stack.template.Resources.CDKMetadata = {
                            Type: 'AWS::CDK::Metadata',
                            Properties: {
                                Modules: modules
                            }
                        };
                    }
                    else {
                        logging_1.warning(`The stack ${stack.name} already includes a CDKMetadata resource`);
                    }
                }
            }
            // All good, return
            this.cachedResponse = response;
            return response;
            function formatModules(runtime) {
                const modules = new Array();
                // inject toolkit version to list of modules
                const toolkitVersion = require('../../../package.json').version;
                modules.push(`aws-cdk=${toolkitVersion}`);
                for (const key of Object.keys(runtime.libraries).sort()) {
                    modules.push(`${key}=${runtime.libraries[key]}`);
                }
                return modules.join(',');
            }
        }
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMessages(stacks) {
        let warnings = false;
        let errors = false;
        for (const stack of stacks) {
            for (const id of Object.keys(stack.metadata)) {
                const metadata = stack.metadata[id];
                for (const entry of metadata) {
                    switch (entry.type) {
                        case cxapi.WARNING_METADATA_KEY:
                            warnings = true;
                            this.printMessage(logging_1.warning, 'Warning', id, entry);
                            break;
                        case cxapi.ERROR_METADATA_KEY:
                            errors = true;
                            this.printMessage(logging_1.error, 'Error', id, entry);
                            break;
                        case cxapi.INFO_METADATA_KEY:
                            this.printMessage(logging_1.print, 'Info', id, entry);
                            break;
                    }
                }
            }
        }
        if (errors && !this.props.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (this.props.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
    }
    printMessage(logFn, prefix, id, entry) {
        logFn(`[${prefix} at ${id}] ${entry.data}`);
        if (this.props.verbose) {
            logFn(`  ${entry.trace.join('\n  ')}`);
        }
    }
    applyRenames(stacks) {
        this.renames.validateSelectedStacks(stacks);
        const ret = [];
        for (const stack of stacks) {
            ret.push(Object.assign({}, stack, { originalName: stack.name, name: this.renames.finalName(stack.name) }));
        }
        return ret;
    }
}
exports.AppStacks = AppStacks;
/**
 * Combine the names of a set of stacks using a comma
 */
function listStackNames(stacks) {
    return stacks.map(s => s.name).join(', ');
}
exports.listStackNames = listStackNames;
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * Include stacks that depend on the stacks already in the set
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const [name, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(name) && (stack.dependsOn || []).some(dependencyName => selectedStacks.has(dependencyName))) {
                selectedStacks.set(name, stack);
                added.push(name);
                madeProgress = true;
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Include stacks that that stacks in the set depend on
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyName of (stack.dependsOn || [])) {
                if (!selectedStacks.has(dependencyName) && allStacks.has(dependencyName)) {
                    added.push(dependencyName);
                    selectedStacks.set(dependencyName, allStacks.get(dependencyName));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLHNDQUF1QztBQUN2Qyx1Q0FBd0M7QUFDeEMsNERBQTZEO0FBQzdELDJDQUE2RDtBQUM3RCwyQ0FBd0M7QUFFeEMsc0NBQXVDO0FBRXZDLCtDQUFtRDtBQStDbkQ7Ozs7R0FJRztBQUNILE1BQWEsU0FBUztJQVFwQixZQUE2QixLQUFxQjtRQUFyQixVQUFLLEdBQUwsS0FBSyxDQUFnQjtRQUNoRCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksSUFBSSxpQkFBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxZQUFZLENBQUMsU0FBbUIsRUFBRSxpQkFBeUM7UUFDdEYsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFdEUsTUFBTSxNQUFNLEdBQTZCLE1BQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2pFLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQixlQUFLLENBQUMsbUVBQW1FLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDcEcsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2xDO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQWtDLENBQUM7UUFDNUQsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7WUFDMUIsU0FBUyxDQUFDLEdB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QUssQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBQzNCLGNBQWMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFFLENBQUMsQ0FBQztvQkFDbkUsWUFBWSxHQUFHLElBQUksQ0FBQztpQkFDckI7YUFDRjtTQUNGO0tBQ0Y7SUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLGVBQUssQ0FBQyxpQ0FBaUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pFO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJyk7XG5pbXBvcnQgY29udGV4dHByb3ZpZGVycyA9IHJlcXVpcmUoJy4uLy4uL2NvbnRleHQtcHJvdmlkZXJzJyk7XG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IsIHByaW50LCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBSZW5hbWVzIH0gZnJvbSAnLi4vLi4vcmVuYW1lcyc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IGNka1V0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5pbXBvcnQgeyBTREsgfSBmcm9tICcuLi91dGlsL3Nkayc7XG5pbXBvcnQgeyB0b3BvbG9naWNhbFNvcnQgfSBmcm9tICcuLi91dGlsL3RvcG9zb3J0JztcblxudHlwZSBTeW50aGVzaXplciA9IChhd3M6IFNESywgY29uZmlnOiBDb25maWd1cmF0aW9uKSA9PiBQcm9taXNlPGN4YXBpLlN5bnRoZXNpemVSZXNwb25zZT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwU3RhY2tzUHJvcHMge1xuICAvKipcbiAgICogV2hldGhlciB0byBiZSB2ZXJib3NlXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB2ZXJib3NlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRG9uJ3Qgc3RvcCBvbiBlcnJvciBtZXRhZGF0YVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlRXJyb3JzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVHJlYXQgd2FybmluZ3MgaW4gbWV0YWRhdGEgYXMgZXJyb3JzXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzdHJpY3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBcHBsaWNhdGlvbiBjb25maWd1cmF0aW9uIChzZXR0aW5ncyBhbmQgY29udGV4dClcbiAgICovXG4gIGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb247XG5cbiAgLyoqXG4gICAqIEFXUyBvYmplY3QgKHVzZWQgYnkgc3ludGhlc2l6ZXIgYW5kIGNvbnRleHRwcm92aWRlcilcbiAgICovXG4gIGF3czogU0RLO1xuXG4gIC8qKlxuICAgKiBSZW5hbWVzIHRvIGFwcGx5XG4gICAqL1xuICByZW5hbWVzPzogUmVuYW1lcztcblxuICAvKipcbiAgICogQ2FsbGJhY2sgaW52b2tlZCB0byBzeW50aGVzaXplIHRoZSBhY3R1YWwgc3RhY2tzXG4gICAqL1xuICBzeW50aGVzaXplcjogU3ludGhlc2l6ZXI7XG59XG5cbi8qKlxuICogUm91dGluZXMgdG8gZ2V0IHN0YWNrcyBmcm9tIGFuIGFwcFxuICpcbiAqIEluIGEgY2xhc3MgYmVjYXVzZSBpdCBzaGFyZXMgc29tZSBnbG9iYWwgc3RhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEFwcFN0YWNrcyB7XG4gIC8qKlxuICAgKiBTaW5jZSBhcHAgZXhlY3V0aW9uIGJhc2ljYWxseSBhbHdheXMgc3ludGhlc2l6ZXMgYWxsIHRoZSBzdGFja3MsXG4gICAqIHdlIGNhbiBpbnZva2UgaXQgb25jZSBhbmQgY2FjaGUgdGhlIHJlc3BvbnNlIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICAgKi9cbiAgcHJpdmF0ZSBjYWNoZWRSZXNwb25zZT86IGN4YXBpLlN5bnRoZXNpemVSZXNwb25zZTtcbiAgcHJpdmF0ZSByZWFkb25seSByZW5hbWVzOiBSZW5hbWVzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IEFwcFN0YWNrc1Byb3BzKSB7XG4gICAgdGhpcy5yZW5hbWVzID0gcHJvcHMucmVuYW1lcyB8fCBuZXcgUmVuYW1lcyh7fSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhbGwgc3RhY2tzIGluIHRoZSBDWCBhbmQgcmV0dXJuIHRoZSBzZWxlY3RlZCBvbmVzXG4gICAqXG4gICAqIEl0J3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIG5vIHN0YWNrcyB0byBzZWxlY3QsIG9yIGlmIG9uZSBvZiB0aGUgcmVxdWVzdGVkIHBhcmFtZXRlcnNcbiAgICogcmVmZXJzIHRvIGEgbm9uZXhpc3RhbnQgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2VsZWN0U3RhY2tzKHNlbGVjdG9yczogc3RyaW5nW10sIGV4dGVuZGVkU2VsZWN0aW9uOiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uKTogUHJvbWlzZTxTZWxlY3RlZFN0YWNrW10+IHtcbiAgICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuZmlsdGVyKHMgPT4gcyAhPSBudWxsKTsgLy8gZmlsdGVyIG51bGwvdW5kZWZpbmVkXG5cbiAgICBjb25zdCBzdGFja3M6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2tbXSA9IGF3YWl0IHRoaXMubGlzdFN0YWNrcygpO1xuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYXBwIGNvbnRhaW5zIG5vIHN0YWNrcycpO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWJ1ZygnU3RhY2sgbmFtZSBub3Qgc3BlY2lmaWVkLCBzbyBkZWZhdWx0aW5nIHRvIGFsbCBhdmFpbGFibGUgc3RhY2tzOiAnICsgbGlzdFN0YWNrTmFtZXMoc3RhY2tzKSk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVJlbmFtZXMoc3RhY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGxTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuU3ludGhlc2l6ZWRTdGFjaz4oKTtcbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgYWxsU3RhY2tzLnNldChzdGFjay5uYW1lLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGV2ZXJ5IHNlbGVjdG9yIGFyZ3VtZW50LCBwaWNrIHN0YWNrcyBmcm9tIHRoZSBsaXN0LlxuICAgIGNvbnN0IHNlbGVjdGVkU3RhY2tzID0gbmV3IE1hcDxzdHJpbmcsIGN4YXBpLlN5bnRoZXNpemVkU3RhY2s+KCk7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHNlbGVjdG9ycykge1xuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGlmIChtaW5pbWF0Y2goc3RhY2submFtZSwgcGF0dGVybikgJiYgIXNlbGVjdGVkU3RhY2tzLmhhcyhzdGFjay5uYW1lKSkge1xuICAgICAgICAgIHNlbGVjdGVkU3RhY2tzLnNldChzdGFjay5uYW1lLCBzdGFjayk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFjayBmb3VuZCBtYXRjaGluZyAnJHtwYXR0ZXJufScuIFVzZSBcImxpc3RcIiB0byBwcmludCBtYW5pZmVzdGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZXh0ZW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIGNhc2UgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Eb3duc3RyZWFtOlxuICAgICAgICBpbmNsdWRlRG93bnN0cmVhbVN0YWNrcyhzZWxlY3RlZFN0YWNrcywgYWxsU3RhY2tzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uVXBzdHJlYW06XG4gICAgICAgIGluY2x1ZGVVcHN0cmVhbVN0YWNrcyhzZWxlY3RlZFN0YWNrcywgYWxsU3RhY2tzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIG9yaWdpbmFsIGFycmF5IGJlY2F1c2UgaXQgaXMgaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgY29uc3Qgc2VsZWN0ZWRMaXN0ID0gc3RhY2tzLmZpbHRlcihzID0+IHNlbGVjdGVkU3RhY2tzLmhhcyhzLm5hbWUpKTtcblxuICAgIC8vIE9ubHkgY2hlY2sgc2VsZWN0ZWQgc3RhY2tzIGZvciBlcnJvcnNcbiAgICB0aGlzLnByb2Nlc3NNZXNzYWdlcyhzZWxlY3RlZExpc3QpO1xuICAgIHJldHVybiB0aGlzLmFwcGx5UmVuYW1lcyhzZWxlY3RlZExpc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgc3RhY2tzIGluIHRoZSBDWFxuICAgKlxuICAgKiBJZiB0aGUgc3RhY2tzIGhhdmUgZGVwZW5kZW5jaWVzIGJldHdlZW4gdGhlbSwgdGhleSB3aWxsIGJlIHJldHVybmVkIGluXG4gICAqIHRvcG9sb2dpY2FsbHkgc29ydGVkIG9yZGVyLiBJZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIG5vdCBpbiB0aGVcbiAgICogc2V0LCB0aGV5IHdpbGwgYmUgaWdub3JlZDsgaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0aGF0IHRoZVxuICAgKiBub24tc2VsZWN0ZWQgc3RhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGRlcGxveWVkIHByZXZpb3VzbHkuXG4gICAqXG4gICAqIFJlbmFtZXMgYXJlICpOT1QqIGFwcGxpZWQgaW4gbGlzdCBtb2RlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RTdGFja3MoKTogUHJvbWlzZTxjeGFwaS5TeW50aGVzaXplZFN0YWNrW10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3ludGhlc2l6ZVN0YWNrcygpO1xuICAgIHJldHVybiB0b3BvbG9naWNhbFNvcnQocmVzcG9uc2Uuc3RhY2tzLCBzID0+IHMubmFtZSwgcyA9PiBzLmRlcGVuZHNPbiB8fCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSBhIHNpbmdsZSBzdGFja1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bnRoZXNpemVTdGFjayhzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8U2VsZWN0ZWRTdGFjaz4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLnN5bnRoZXNpemVTdGFja3MoKTtcbiAgICBjb25zdCBzdGFjayA9IHJlc3Auc3RhY2tzLmZpbmQocyA9PiBzLm5hbWUgPT09IHN0YWNrTmFtZSk7XG4gICAgaWYgKCFzdGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGFjayAke3N0YWNrTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFwcGx5UmVuYW1lcyhbc3RhY2tdKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2V0IG9mIHN0YWNrc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bnRoZXNpemVTdGFja3MoKTogUHJvbWlzZTxjeGFwaS5TeW50aGVzaXplUmVzcG9uc2U+IHtcbiAgICBpZiAodGhpcy5jYWNoZWRSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhY2tWZXJzaW9uczogYm9vbGVhbiA9IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd2ZXJzaW9uUmVwb3J0aW5nJ10pO1xuXG4gICAgLy8gV2UgbWF5IG5lZWQgdG8gcnVuIHRoZSBjbG91ZCBleGVjdXRhYmxlIG11bHRpcGxlIHRpbWVzIGluIG9yZGVyIHRvIHNhdGlzZnkgYWxsIG1pc3NpbmcgY29udGV4dFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCByZXNwb25zZTogY3hhcGkuU3ludGhlc2l6ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9wcy5zeW50aGVzaXplcih0aGlzLnByb3BzLmF3cywgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGFsbE1pc3NpbmcgPSBjZGtVdGlsLmRlZXBNZXJnZSguLi5yZXNwb25zZS5zdGFja3MubWFwKHMgPT4gcy5taXNzaW5nKSk7XG5cbiAgICAgIGlmICghY2RrVXRpbC5pc0VtcHR5KGFsbE1pc3NpbmcpKSB7XG4gICAgICAgIGRlYnVnKGBTb21lIGNvbnRleHQgaW5mb3JtYXRpb24gaXMgbWlzc2luZy4gRmV0Y2hpbmcuLi5gKTtcblxuICAgICAgICBhd2FpdCBjb250ZXh0cHJvdmlkZXJzLnByb3ZpZGVDb250ZXh0VmFsdWVzKGFsbE1pc3NpbmcsIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5jb250ZXh0LCB0aGlzLnByb3BzLmF3cyk7XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIG5ldyBjb250ZXh0IHRvIGRpc2tcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNhdmVDb250ZXh0KCk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFja1ZlcnNpb25zICYmIHJlc3BvbnNlLnJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGZvcm1hdE1vZHVsZXMocmVzcG9uc2UucnVudGltZSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2YgcmVzcG9uc2Uuc3RhY2tzKSB7XG4gICAgICAgICAgaWYgKCFzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHN0YWNrLnRlbXBsYXRlLlJlc291cmNlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YSkge1xuICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhID0ge1xuICAgICAgICAgICAgICBUeXBlOiAnQVdTOjpDREs6Ok1ldGFkYXRhJyxcbiAgICAgICAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIE1vZHVsZXM6IG1vZHVsZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybmluZyhgVGhlIHN0YWNrICR7c3RhY2submFtZX0gYWxyZWFkeSBpbmNsdWRlcyBhIENES01ldGFkYXRhIHJlc291cmNlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBnb29kLCByZXR1cm5cbiAgICAgIHRoaXMuY2FjaGVkUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcblxuICAgICAgZnVuY3Rpb24gZm9ybWF0TW9kdWxlcyhydW50aW1lOiBjeGFwaS5BcHBSdW50aW1lKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICAgICAgLy8gaW5qZWN0IHRvb2xraXQgdmVyc2lvbiB0byBsaXN0IG9mIG1vZHVsZXNcbiAgICAgICAgY29uc3QgdG9vbGtpdFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgICAgICBtb2R1bGVzLnB1c2goYGF3cy1jZGs9JHt0b29sa2l0VmVyc2lvbn1gKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhydW50aW1lLmxpYnJhcmllcykuc29ydCgpKSB7XG4gICAgICAgICAgbW9kdWxlcy5wdXNoKGAke2tleX09JHtydW50aW1lLmxpYnJhcmllc1trZXldfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVzLmpvaW4oJywnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgJ2F3czpjZGs6d2FybmluZ3xpbmZvfGVycm9yJyBtZXRhZGF0YSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrIHN5bnRoZXNpc1xuICAgKi9cbiAgcHJpdmF0ZSBwcm9jZXNzTWVzc2FnZXMoc3RhY2tzOiBjeGFwaS5TeW50aGVzaXplZFN0YWNrW10pIHtcbiAgICBsZXQgd2FybmluZ3MgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JzID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMoc3RhY2subWV0YWRhdGEpKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gc3RhY2subWV0YWRhdGFbaWRdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1ldGFkYXRhKSB7XG4gICAgICAgICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGN4YXBpLldBUk5JTkdfTUVUQURBVEFfS0VZOlxuICAgICAgICAgICAgICB3YXJuaW5ncyA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRNZXNzYWdlKHdhcm5pbmcsICdXYXJuaW5nJywgaWQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGN4YXBpLkVSUk9SX01FVEFEQVRBX0tFWTpcbiAgICAgICAgICAgICAgZXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5wcmludE1lc3NhZ2UoZXJyb3IsICdFcnJvcicsIGlkLCBlbnRyeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjeGFwaS5JTkZPX01FVEFEQVRBX0tFWTpcbiAgICAgICAgICAgICAgdGhpcy5wcmludE1lc3NhZ2UocHJpbnQsICdJbmZvJywgaWQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycyAmJiAhdGhpcy5wcm9wcy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgZXJyb3JzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuc3RyaWN0ICYmIHdhcm5pbmdzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHdhcm5pbmdzICgtLXN0cmljdCBtb2RlKScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJpbnRNZXNzYWdlKGxvZ0ZuOiAoczogc3RyaW5nKSA9PiB2b2lkLCBwcmVmaXg6IHN0cmluZywgaWQ6IHN0cmluZywgZW50cnk6IGN4YXBpLk1ldGFkYXRhRW50cnkpIHtcbiAgICBsb2dGbihgWyR7cHJlZml4fSBhdCAke2lkfV0gJHtlbnRyeS5kYXRhfWApO1xuXG4gICAgaWYgKHRoaXMucHJvcHMudmVyYm9zZSkge1xuICAgICAgbG9nRm4oYCAgJHtlbnRyeS50cmFjZS5qb2luKCdcXG4gICcpfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlSZW5hbWVzKHN0YWNrczogY3hhcGkuU3ludGhlc2l6ZWRTdGFja1tdKTogU2VsZWN0ZWRTdGFja1tdIHtcbiAgICB0aGlzLnJlbmFtZXMudmFsaWRhdGVTZWxlY3RlZFN0YWNrcyhzdGFja3MpO1xuXG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgLi4uc3RhY2ssXG4gICAgICAgIG9yaWdpbmFsTmFtZTogc3RhY2submFtZSxcbiAgICAgICAgbmFtZTogdGhpcy5yZW5hbWVzLmZpbmFsTmFtZShzdGFjay5uYW1lKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaW5lIHRoZSBuYW1lcyBvZiBhIHNldCBvZiBzdGFja3MgdXNpbmcgYSBjb21tYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdFN0YWNrTmFtZXMoc3RhY2tzOiBjeGFwaS5TeW50aGVzaXplZFN0YWNrW10pOiBzdHJpbmcge1xuICByZXR1cm4gc3RhY2tzLm1hcChzID0+IHMubmFtZSkuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBXaGVuIHNlbGVjdGluZyBzdGFja3MsIHdoYXQgb3RoZXIgc3RhY2tzIHRvIGluY2x1ZGUgYmVjYXVzZSBvZiBkZXBlbmRlbmNpZXNcbiAqL1xuZXhwb3J0IGVudW0gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbiB7XG4gIC8qKlxuICAgKiBEb24ndCBzZWxlY3QgYW55IGV4dHJhIHN0YWNrc1xuICAgKi9cbiAgTm9uZSxcblxuICAvKipcbiAgICogSW5jbHVkZSBzdGFja3MgdGhhdCB0aGlzIHN0YWNrIGRlcGVuZHMgb25cbiAgICovXG4gIFVwc3RyZWFtLFxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHN0YWNrcyB0aGF0IGRlcGVuZCBvbiB0aGlzIHN0YWNrXG4gICAqL1xuICBEb3duc3RyZWFtXG59XG5cbi8qKlxuICogSW5jbHVkZSBzdGFja3MgdGhhdCBkZXBlbmQgb24gdGhlIHN0YWNrcyBhbHJlYWR5IGluIHRoZSBzZXRcbiAqXG4gKiBNb2RpZmllcyBgc2VsZWN0ZWRTdGFja3NgIGluLXBsYWNlLlxuICovXG5mdW5jdGlvbiBpbmNsdWRlRG93bnN0cmVhbVN0YWNrcyhzZWxlY3RlZFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuU3ludGhlc2l6ZWRTdGFjaz4sIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuU3ludGhlc2l6ZWRTdGFjaz4pIHtcbiAgY29uc3QgYWRkZWQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBzdGFja10gb2YgYWxsU3RhY2tzKSB7XG4gICAgICAvLyBTZWxlY3QgdGhpcyBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgQU5EIGl0IGRlcGVuZHMgb24gYSBzdGFjayB0aGF0J3MgaW4gdGhlIHNlbGVjdGVkIHNldFxuICAgICAgaWYgKCFzZWxlY3RlZFN0YWNrcy5oYXMobmFtZSkgJiYgKHN0YWNrLmRlcGVuZHNPbiB8fCBbXSkuc29tZShkZXBlbmRlbmN5TmFtZSA9PiBzZWxlY3RlZFN0YWNrcy5oYXMoZGVwZW5kZW5jeU5hbWUpKSkge1xuICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQobmFtZSwgc3RhY2spO1xuICAgICAgICBhZGRlZC5wdXNoKG5hbWUpO1xuICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgcHJpbnQoJ0luY2x1ZGluZyBkZXBlbmRpbmcgc3RhY2tzOiAlcycsIGNvbG9ycy5ib2xkKGFkZGVkLmpvaW4oJywgJykpKTtcbiAgfVxufVxuXG4vKipcbiAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgdGhhdCBzdGFja3MgaW4gdGhlIHNldCBkZXBlbmQgb25cbiAqXG4gKiBNb2RpZmllcyBgc2VsZWN0ZWRTdGFja3NgIGluLXBsYWNlLlxuICovXG5mdW5jdGlvbiBpbmNsdWRlVXBzdHJlYW1TdGFja3Moc2VsZWN0ZWRTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLlN5bnRoZXNpemVkU3RhY2s+LCBhbGxTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLlN5bnRoZXNpemVkU3RhY2s+KSB7XG4gIGNvbnN0IGFkZGVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgbGV0IG1hZGVQcm9ncmVzcyA9IHRydWU7XG4gIHdoaWxlIChtYWRlUHJvZ3Jlc3MpIHtcbiAgICBtYWRlUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc2VsZWN0ZWRTdGFja3MudmFsdWVzKCkpIHtcbiAgICAgIC8vIFNlbGVjdCBhbiBhZGRpdGlvbmFsIHN0YWNrIGlmIGl0J3Mgbm90IHNlbGVjdGVkIHlldCBhbmQgYSBkZXBlbmRlbmN5IG9mIGEgc2VsZWN0ZWQgc3RhY2sgKGFuZCBleGlzdHMsIG9idmlvdXNseSlcbiAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeU5hbWUgb2YgKHN0YWNrLmRlcGVuZHNPbiB8fCBbXSkpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RlZFN0YWNrcy5oYXMoZGVwZW5kZW5jeU5hbWUpICYmIGFsbFN0YWNrcy5oYXMoZGVwZW5kZW5jeU5hbWUpKSB7XG4gICAgICAgICAgYWRkZWQucHVzaChkZXBlbmRlbmN5TmFtZSk7XG4gICAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KGRlcGVuZGVuY3lOYW1lLCBhbGxTdGFja3MuZ2V0KGRlcGVuZGVuY3lOYW1lKSEpO1xuICAgICAgICAgIG1hZGVQcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHByaW50KCdJbmNsdWRpbmcgZGVwZW5kZW5jeSBzdGFja3M6ICVzJywgY29sb3JzLmJvbGQoYWRkZWQuam9pbignLCAnKSkpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0ZWRTdGFjayBleHRlbmRzIGN4YXBpLlN5bnRoZXNpemVkU3RhY2sge1xuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIG5hbWUgb2YgdGhlIHN0YWNrIGJlZm9yZSByZW5hbWluZ1xuICAgKi9cbiAgb3JpZ2luYWxOYW1lOiBzdHJpbmc7XG59Il19