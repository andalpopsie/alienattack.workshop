"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
const account_cache_1 = require("./account-cache");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Source for SDK client objects
 *
 * Credentials are first obtained from the SDK defaults (using environment variables and the
 * ~/.aws/{config,credentials} files).
 *
 * If those don't suffice, a list of CredentialProviderSources is interrogated for access
 * to the requested account.
 */
class SDK {
    constructor(options = {}) {
        this.profile = options.profile;
        const defaultCredentialProvider = makeCLICompatibleCredentialProvider(options.profile, options.ec2creds);
        // Find the package.json from the main toolkit
        const pkg = require.main.require('../package.json');
        AWS.config.update({
            customUserAgent: `${pkg.name}/${pkg.version}`
        });
        // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
        if (options.proxyAddress === undefined) {
            options.proxyAddress = httpsProxyFromEnvironment();
        }
        if (options.proxyAddress) { // Ignore empty string on purpose
            logging_1.debug('Using proxy server: %s', options.proxyAddress);
            AWS.config.update({
                httpOptions: { agent: require('proxy-agent')(options.proxyAddress) }
            });
        }
        this.defaultAwsAccount = new DefaultAWSAccount(defaultCredentialProvider, getCLICompatibleDefaultRegion(this.profile));
        this.credentialsCache = new CredentialsCache(this.defaultAwsAccount, defaultCredentialProvider);
    }
    async cloudFormation(environment, mode) {
        return new AWS.CloudFormation({
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async ec2(awsAccountId, region, mode) {
        return new AWS.EC2({
            region,
            credentials: await this.credentialsCache.get(awsAccountId, mode)
        });
    }
    async ssm(awsAccountId, region, mode) {
        return new AWS.SSM({
            region,
            credentials: await this.credentialsCache.get(awsAccountId, mode)
        });
    }
    async s3(environment, mode) {
        return new AWS.S3({
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async route53(awsAccountId, region, mode) {
        return new AWS.Route53({
            region,
            credentials: await this.credentialsCache.get(awsAccountId, mode),
        });
    }
    async ecr(environment, mode) {
        return new AWS.ECR({
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async defaultRegion() {
        return await getCLICompatibleDefaultRegion(this.profile);
    }
    defaultAccount() {
        return this.defaultAwsAccount.get();
    }
}
exports.SDK = SDK;
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialsCache {
    constructor(defaultAwsAccount, defaultCredentialProvider) {
        this.defaultAwsAccount = defaultAwsAccount;
        this.defaultCredentialProvider = defaultCredentialProvider;
        this.cache = {};
    }
    async get(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.getCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    async getCredentials(awsAccountId, mode) {
        // If requested account is undefined or equal to default account, use default credentials provider.
        // (Note that we ignore the mode in this case, if you preloaded credentials they better be correct!)
        const defaultAccount = await this.defaultAwsAccount.get();
        if (!awsAccountId || awsAccountId === defaultAccount) {
            logging_1.debug(`Using default AWS SDK credentials for account ${awsAccountId}`);
            // CredentialProviderChain extends Credentials, but that is a lie.
            // https://github.com/aws/aws-sdk-js/issues/2235
            // Call resolve() instead.
            return (await this.defaultCredentialProvider).resolvePromise();
        }
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        const sourceNames = ['default credentials'].concat(triedSources.map(s => s.name)).join(', ');
        throw new Error(`Need to perform AWS calls for account ${awsAccountId}, but no credentials found. Tried: ${sourceNames}.`);
    }
}
/**
 * Class to retrieve the account for default credentials and cache it.
 *
 * Uses the default credentials provider to obtain credentials (if available),
 * and uses those credentials to call STS to request the current account ID.
 *
 * The credentials => accountId lookup is cached on disk, since it's
 * guaranteed that igven access key will always remain for the same account.
 */
class DefaultAWSAccount {
    constructor(defaultCredentialsProvider, region) {
        this.defaultCredentialsProvider = defaultCredentialsProvider;
        this.region = region;
        this.defaultAccountFetched = false;
        this.defaultAccountId = undefined;
        this.accountCache = new account_cache_1.AccountAccessKeyCache();
    }
    /**
     * Return the default account
     */
    async get() {
        if (!this.defaultAccountFetched) {
            this.defaultAccountId = await this.lookupDefaultAccount();
            this.defaultAccountFetched = true;
        }
        return this.defaultAccountId;
    }
    async lookupDefaultAccount() {
        try {
            // There just is *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set. The SDK
            // crash if the file does not exist though. So set the environment variable if we can find that file.
            await setConfigVariable();
            logging_1.debug('Resolving default credentials');
            const credentialProvider = await this.defaultCredentialsProvider;
            const creds = await credentialProvider.resolvePromise();
            const accessKeyId = creds.accessKeyId;
            if (!accessKeyId) {
                throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
            }
            const accountId = await this.accountCache.fetch(creds.accessKeyId, async () => {
                // if we don't have one, resolve from STS and store in cache.
                logging_1.debug('Looking up default account ID from STS');
                const result = await new AWS.STS({ credentials: creds, region: await this.region }).getCallerIdentity().promise();
                const aid = result.Account;
                if (!aid) {
                    logging_1.debug('STS didn\'t return an account ID');
                    return undefined;
                }
                logging_1.debug('Default account ID:', aid);
                return aid;
            });
            return accountId;
        }
        catch (e) {
            logging_1.debug('Unable to determine the default AWS account (did you configure "aws configure"?):', e);
            return undefined;
        }
    }
}
/**
 * Build an AWS CLI-compatible credential chain provider
 *
 * This is similar to the default credential provider chain created by the SDK
 * except it also accepts the profile argument in the constructor (not just from
 * the environment).
 *
 * To mimic the AWS CLI behavior:
 *
 * - we default to ~/.aws/credentials if environment variable for credentials
 * file location is not given (SDK expects explicit environment variable with name).
 * - AWS_DEFAULT_PROFILE is also inspected for profile name (not just AWS_PROFILE).
 */
async function makeCLICompatibleCredentialProvider(profile, ec2creds) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Need to construct filename ourselves, without appropriate environment variables
    // no defaults used by JS SDK.
    const filename = process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(os.homedir(), '.aws', 'credentials');
    const sources = [
        () => new AWS.EnvironmentCredentials('AWS'),
        () => new AWS.EnvironmentCredentials('AMAZON'),
    ];
    if (fs.pathExists(filename)) {
        sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename }));
    }
    if (hasEcsCredentials()) {
        sources.push(() => new AWS.ECSCredentials());
    }
    else {
        // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
        // run on EC2 boxes but the creds represent something different. Same behavior as
        // upstream code.
        if (ec2creds === undefined) {
            ec2creds = await hasEc2Credentials();
        }
        if (ec2creds) {
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
    }
    return new AWS.CredentialProviderChain(sources);
}
/**
 * Return the default region in a CLI-compatible way
 *
 * Mostly copied from node_loader.js, but with the following differences:
 *
 * - Takes a runtime profile name to load the region from, not just based on environment
 *   variables at process start.
 * - We have needed to create a local copy of the SharedIniFile class because the
 *   implementation in 'aws-sdk' is private (and the default use of it in the
 *   SDK does not allow us to specify a profile at runtime).
 * - AWS_DEFAULT_PROFILE and AWS_DEFAULT_REGION are also used as environment
 *   variables to be used to determine the region.
 */
async function getCLICompatibleDefaultRegion(profile) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Defaults inside constructor
    const toCheck = [
        { filename: process.env.AWS_SHARED_CREDENTIALS_FILE },
        { isConfig: true, filename: process.env.AWS_CONFIG_FILE },
    ];
    let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
        process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
    while (!region && toCheck.length > 0) {
        const configFile = new sdk_ini_file_1.SharedIniFile(toCheck.shift());
        const section = await configFile.getProfile(profile);
        region = section && section.region;
    }
    return region;
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, await readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
async function setConfigVariable() {
    const homeDir = process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
    if (await fs.pathExists(path.resolve(homeDir, '.aws', 'config'))) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
async function readIfPossible(filename) {
    try {
        if (!await fs.pathExists(filename)) {
            return undefined;
        }
        return fs.readFile(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsK0JBQWdDO0FBQ2hDLCtDQUFnRDtBQUNoRCwrQkFBZ0M7QUFDaEMseUJBQTBCO0FBQzFCLDZCQUE4QjtBQUM5Qiw2QkFBOEI7QUFDOUIsMkNBQXNDO0FBQ3RDLHlDQUEwQztBQUUxQyxtREFBd0Q7QUFDeEQsaURBQStDO0FBMkIvQzs7Ozs7Ozs7R0FRRztBQUNILE1BQWEsR0FBRztJQUtkLFlBQVksVUFBc0IsRUFBRTtRQUNsQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFFL0IsTUFBTSx5QkFBeUIsR0FBRyxtQ0FBbUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV6Ryw4Q0FBOEM7UUFDOUMsTUFBTSxHQUFHLEdBQUksT0FBTyxDQUFDLElBQVksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUM3RCxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztZQUNkLGVBQWUsRUFBRSxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRTtTQUNoRCxDQUFDLENBQUM7UUFFSCwrRkFBK0Y7UUFDL0YsSUFBSSxPQUFPLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRTtZQUN0QyxPQUFPLENBQUMsWUFBWSxHQUFHLHlCQUF5QixFQUFFLENBQUM7U0FDcEQ7UUFDRCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxpQ0FBaUM7WUFDM0QsZUFBSyxDQUFDLHdCQUF3QixFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN0RCxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztnQkFDaEIsV0FBVyxFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxD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QyxFQUFFO1FBQ2hFLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEdBQUcsR0FBRyxDQUFDO0tBQ3ZDO0FBQ0gsQ0FBQztBQUVELEtBQUssVUFBVSxjQUFjLENBQUMsUUFBZ0I7SUFDNUMsSUFBSTtRQUNGLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFNBQVMsQ0FBQztTQUFFO1FBQ3pELE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUNyRDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsZUFBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1QsT0FBTyxTQUFTLENBQUM7S0FDbEI7QUFDSCxDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUMsRUFBVSxFQUFFLENBQXFCO0lBQ3JELE9BQU8sQ0FBQyxLQUFLLFNBQVMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQztBQUNoRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW52aXJvbm1lbnR9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgQVdTID0gcmVxdWlyZSgnYXdzLXNkaycpO1xuaW1wb3J0IGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5pbXBvcnQgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xuaW1wb3J0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuaW1wb3J0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgUGx1Z2luSG9zdCB9IGZyb20gJy4uLy4uL3BsdWdpbic7XG5pbXBvcnQgeyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UsIE1vZGUgfSBmcm9tICcuLi9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUgfSBmcm9tICcuL2FjY291bnQtY2FjaGUnO1xuaW1wb3J0IHsgU2hhcmVkSW5pRmlsZSB9IGZyb20gJy4vc2RrX2luaV9maWxlJztcblxuZXhwb3J0IGludGVyZmFjZSBTREtPcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb2ZpbGUgbmFtZSB0byB1c2VcbiAgICpcbiAgICogQGRlZmF1bHQgTm8gcHJvZmlsZVxuICAgKi9cbiAgcHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogUHJveHkgYWRkcmVzcyB0byB1c2VcbiAgICpcbiAgICogQGRlZmF1bHQgTm8gcHJveHlcbiAgICovXG4gIHByb3h5QWRkcmVzcz86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgdHJ5IGluc3RhbmNlIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIFRydWUvZmFsc2UgdG8gZm9yY2UvZGlzYWJsZS4gRGVmYXVsdCBpcyB0byBndWVzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgQXV0b21hdGljYWxseSBkZXRlcm1pbmUuXG4gICAqL1xuICBlYzJjcmVkcz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogU291cmNlIGZvciBTREsgY2xpZW50IG9iamVjdHNcbiAqXG4gKiBDcmVkZW50aWFscyBhcmUgZmlyc3Qgb2J0YWluZWQgZnJvbSB0aGUgU0RLIGRlZmF1bHRzICh1c2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIHRoZVxuICogfi8uYXdzL3tjb25maWcsY3JlZGVudGlhbHN9IGZpbGVzKS5cbiAqXG4gKiBJZiB0aG9zZSBkb24ndCBzdWZmaWNlLCBhIGxpc3Qgb2YgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlcyBpcyBpbnRlcnJvZ2F0ZWQgZm9yIGFjY2Vzc1xuICogdG8gdGhlIHJlcXVlc3RlZCBhY2NvdW50LlxuICovXG5leHBvcnQgY2xhc3MgU0RLIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0QXdzQWNjb3VudDogRGVmYXVsdEFXU0FjY291bnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgY3JlZGVudGlhbHNDYWNoZTogQ3JlZGVudGlhbHNDYWNoZTtcbiAgcHJpdmF0ZSByZWFkb25seSBwcm9maWxlPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFNES09wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucHJvZmlsZSA9IG9wdGlvbnMucHJvZmlsZTtcblxuICAgIGNvbnN0IGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIgPSBtYWtlQ0xJQ29tcGF0aWJsZUNyZWRlbnRpYWxQcm92aWRlcihvcHRpb25zLnByb2ZpbGUsIG9wdGlvbnMuZWMyY3JlZHMpO1xuXG4gICAgLy8gRmluZCB0aGUgcGFja2FnZS5qc29uIGZyb20gdGhlIG1haW4gdG9vbGtpdFxuICAgIGNvbnN0IHBrZyA9IChyZXF1aXJlLm1haW4gYXMgYW55KS5yZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbiAgICBBV1MuY29uZmlnLnVwZGF0ZSh7XG4gICAgICAgIGN1c3RvbVVzZXJBZ2VudDogYCR7cGtnLm5hbWV9LyR7cGtnLnZlcnNpb259YFxuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9ibG9ncy9kZXZlbG9wZXIvdXNpbmctdGhlLWF3cy1zZGstZm9yLWphdmFzY3JpcHQtZnJvbS1iZWhpbmQtYS1wcm94eS9cbiAgICBpZiAob3B0aW9ucy5wcm94eUFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5wcm94eUFkZHJlc3MgPSBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb3h5QWRkcmVzcykgeyAvLyBJZ25vcmUgZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAgIGRlYnVnKCdVc2luZyBwcm94eSBzZXJ2ZXI6ICVzJywgb3B0aW9ucy5wcm94eUFkZHJlc3MpO1xuICAgICAgQVdTLmNvbmZpZy51cGRhdGUoe1xuICAgICAgICBodHRwT3B0aW9uczogeyBhZ2VudDogcmVxdWlyZSgncHJveHktYWdlbnQnKShvcHRpb25zLnByb3h5QWRkcmVzcykgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZhdWx0QXdzQWNjb3VudCA9IG5ldyBEZWZhdWx0QVdTQWNjb3VudChkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyLCBnZXRDTElDb21wYXRpYmxlRGVmYXVsdFJlZ2lvbih0aGlzLnByb2ZpbGUpKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUgPSBuZXcgQ3JlZGVudGlhbHNDYWNoZSh0aGlzLmRlZmF1bHRBd3NBY2NvdW50LCBkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbG91ZEZvcm1hdGlvbihlbnZpcm9ubWVudDogRW52aXJvbm1lbnQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbj4ge1xuICAgIHJldHVybiBuZXcgQVdTLkNsb3VkRm9ybWF0aW9uKHtcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlYzIoYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUMyPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuRUMyKHtcbiAgICAgIHJlZ2lvbixcbiAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUuZ2V0KGF3c0FjY291bnRJZCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzc20oYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuU1NNPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuU1NNKHtcbiAgICAgIHJlZ2lvbixcbiAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUuZ2V0KGF3c0FjY291bnRJZCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzMyhlbnZpcm9ubWVudDogRW52aXJvbm1lbnQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5TMz4ge1xuICAgIHJldHVybiBuZXcgQVdTLlMzKHtcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByb3V0ZTUzKGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlJvdXRlNTM+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5Sb3V0ZTUzKHtcbiAgICAgIHJlZ2lvbixcbiAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUuZ2V0KGF3c0FjY291bnRJZCwgbW9kZSksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZWNyKGVudmlyb25tZW50OiBFbnZpcm9ubWVudCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkVDUj4ge1xuICAgIHJldHVybiBuZXcgQVdTLkVDUih7XG4gICAgICByZWdpb246IGVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUuZ2V0KGVudmlyb25tZW50LmFjY291bnQsIG1vZGUpXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVmYXVsdFJlZ2lvbigpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBhd2FpdCBnZXRDTElDb21wYXRpYmxlRGVmYXVsdFJlZ2lvbih0aGlzLnByb2ZpbGUpO1xuICB9XG5cbiAgcHVibGljIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF3c0FjY291bnQuZ2V0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWNoZSBmb3IgY3JlZGVudGlhbCBwcm92aWRlcnMuXG4gKlxuICogR2l2ZW4gYW4gYWNjb3VudCBhbmQgYW4gb3BlcmF0aW5nIG1vZGUgKHJlYWQgb3Igd3JpdGUpIHdpbGwgcmV0dXJuIGFuXG4gKiBhcHByb3ByaWF0ZSBjcmVkZW50aWFsIHByb3ZpZGVyIGZvciBjcmVkZW50aWFscyBmb3IgdGhlIGdpdmVuIGFjY291bnQuIFRoZVxuICogY3JlZGVudGlhbCBwcm92aWRlciB3aWxsIGJlIGNhY2hlZCBzbyB0aGF0IG11bHRpcGxlIEFXUyBjbGllbnRzIGZvciB0aGUgc2FtZVxuICogZW52aXJvbm1lbnQgd2lsbCBub3QgbWFrZSBtdWx0aXBsZSBuZXR3b3JrIGNhbGxzIHRvIG9idGFpbiBjcmVkZW50aWFscy5cbiAqXG4gKiBXaWxsIHVzZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZXkgYXJlIGZvciB0aGUgcmlnaHQgYWNjb3VudDsgb3RoZXJ3aXNlLFxuICogYWxsIGxvYWRlZCBjcmVkZW50aWFsIHByb3ZpZGVyIHBsdWdpbnMgd2lsbCBiZSB0cmllZCB0byBvYnRhaW4gY3JlZGVudGlhbHNcbiAqIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC5cbiAqL1xuY2xhc3MgQ3JlZGVudGlhbHNDYWNoZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGU6IHtba2V5OiBzdHJpbmddOiBBV1MuQ3JlZGVudGlhbHN9ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEF3c0FjY291bnQ6IERlZmF1bHRBV1NBY2NvdW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcjogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4+KSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICBjb25zdCBrZXkgPSBgJHthd3NBY2NvdW50SWR9LSR7bW9kZX1gO1xuICAgIGlmICghKGtleSBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgdGhpcy5jYWNoZVtrZXldID0gYXdhaXQgdGhpcy5nZXRDcmVkZW50aWFscyhhd3NBY2NvdW50SWQsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRDcmVkZW50aWFscyhhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxzPiB7XG4gICAgLy8gSWYgcmVxdWVzdGVkIGFjY291bnQgaXMgdW5kZWZpbmVkIG9yIGVxdWFsIHRvIGRlZmF1bHQgYWNjb3VudCwgdXNlIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXIuXG4gICAgLy8gKE5vdGUgdGhhdCB3ZSBpZ25vcmUgdGhlIG1vZGUgaW4gdGhpcyBjYXNlLCBpZiB5b3UgcHJlbG9hZGVkIGNyZWRlbnRpYWxzIHRoZXkgYmV0dGVyIGJlIGNvcnJlY3QhKVxuICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50ID0gYXdhaXQgdGhpcy5kZWZhdWx0QXdzQWNjb3VudC5nZXQoKTtcbiAgICBpZiAoIWF3c0FjY291bnRJZCB8fCBhd3NBY2NvdW50SWQgPT09IGRlZmF1bHRBY2NvdW50KSB7XG4gICAgICBkZWJ1ZyhgVXNpbmcgZGVmYXVsdCBBV1MgU0RLIGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuXG4gICAgICAvLyBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbiBleHRlbmRzIENyZWRlbnRpYWxzLCBidXQgdGhhdCBpcyBhIGxpZS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9pc3N1ZXMvMjIzNVxuICAgICAgLy8gQ2FsbCByZXNvbHZlKCkgaW5zdGVhZC5cbiAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyKS5yZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaWVkU291cmNlczogQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlW10gPSBbXTtcbiAgICAvLyBPdGhlcndpc2UsIGluc3BlY3QgdGhlIHZhcmlvdXMgY3JlZGVudGlhbCBzb3VyY2VzIHdlIGhhdmVcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBQbHVnaW5Ib3N0Lmluc3RhbmNlLmNyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMpIHtcbiAgICAgIGlmICghKGF3YWl0IHNvdXJjZS5pc0F2YWlsYWJsZSgpKSkge1xuICAgICAgICBkZWJ1ZygnQ3JlZGVudGlhbHMgc291cmNlICVzIGlzIG5vdCBhdmFpbGFibGUsIGlnbm9yaW5nIGl0LicsIHNvdXJjZS5uYW1lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmllZFNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgaWYgKCEoYXdhaXQgc291cmNlLmNhblByb3ZpZGVDcmVkZW50aWFscyhhd3NBY2NvdW50SWQpKSkgeyBjb250aW51ZTsgfVxuICAgICAgZGVidWcoYFVzaW5nICR7c291cmNlLm5hbWV9IGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuICAgICAgY29uc3QgcHJvdmlkZXJPckNyZWRzID0gYXdhaXQgc291cmNlLmdldFByb3ZpZGVyKGF3c0FjY291bnRJZCwgbW9kZSk7XG5cbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiB0aGUgcGx1Z2luIHJldHVybnMgYSBQcm92aWRlckNoYWluLCByZXNvbHZlIHRoYXQgY2hhaW4uXG4gICAgICAvLyBPdGhlcndpc2UgaXQgbXVzdCBoYXZlIHJldHVybmVkIGNyZWRlbnRpYWxzLlxuICAgICAgaWYgKChwcm92aWRlck9yQ3JlZHMgYXMgYW55KS5yZXNvbHZlUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgKHByb3ZpZGVyT3JDcmVkcyBhcyBhbnkpLnJlc29sdmVQcm9taXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvdmlkZXJPckNyZWRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VOYW1lcyA9IFsnZGVmYXVsdCBjcmVkZW50aWFscyddLmNvbmNhdCh0cmllZFNvdXJjZXMubWFwKHMgPT4gcy5uYW1lKSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5lZWQgdG8gcGVyZm9ybSBBV1MgY2FsbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9LCBidXQgbm8gY3JlZGVudGlhbHMgZm91bmQuIFRyaWVkOiAke3NvdXJjZU5hbWVzfS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHRvIHJldHJpZXZlIHRoZSBhY2NvdW50IGZvciBkZWZhdWx0IGNyZWRlbnRpYWxzIGFuZCBjYWNoZSBpdC5cbiAqXG4gKiBVc2VzIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRvIG9idGFpbiBjcmVkZW50aWFscyAoaWYgYXZhaWxhYmxlKSxcbiAqIGFuZCB1c2VzIHRob3NlIGNyZWRlbnRpYWxzIHRvIGNhbGwgU1RTIHRvIHJlcXVlc3QgdGhlIGN1cnJlbnQgYWNjb3VudCBJRC5cbiAqXG4gKiBUaGUgY3JlZGVudGlhbHMgPT4gYWNjb3VudElkIGxvb2t1cCBpcyBjYWNoZWQgb24gZGlzaywgc2luY2UgaXQnc1xuICogZ3VhcmFudGVlZCB0aGF0IGlndmVuIGFjY2VzcyBrZXkgd2lsbCBhbHdheXMgcmVtYWluIGZvciB0aGUgc2FtZSBhY2NvdW50LlxuICovXG5jbGFzcyBEZWZhdWx0QVdTQWNjb3VudCB7XG4gIHByaXZhdGUgZGVmYXVsdEFjY291bnRGZXRjaGVkID0gZmFsc2U7XG4gIHByaXZhdGUgZGVmYXVsdEFjY291bnRJZD86IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2NvdW50Q2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDcmVkZW50aWFsc1Byb3ZpZGVyOiBQcm9taXNlPEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbj4sXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvbjogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGFjY291bnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoIXRoaXMuZGVmYXVsdEFjY291bnRGZXRjaGVkKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBY2NvdW50SWQgPSBhd2FpdCB0aGlzLmxvb2t1cERlZmF1bHRBY2NvdW50KCk7XG4gICAgICB0aGlzLmRlZmF1bHRBY2NvdW50RmV0Y2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBY2NvdW50SWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvb2t1cERlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlIGp1c3QgaXMgKk5PKiB3YXkgdG8gZG8gQXNzdW1lUm9sZSBjcmVkZW50aWFscyBhcyBsb25nIGFzIEFXU19TREtfTE9BRF9DT05GSUcgaXMgbm90IHNldC4gVGhlIFNES1xuICAgICAgLy8gY3Jhc2ggaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QgdGhvdWdoLiBTbyBzZXQgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIHdlIGNhbiBmaW5kIHRoYXQgZmlsZS5cbiAgICAgIGF3YWl0IHNldENvbmZpZ1ZhcmlhYmxlKCk7XG5cbiAgICAgIGRlYnVnKCdSZXNvbHZpbmcgZGVmYXVsdCBjcmVkZW50aWFscycpO1xuICAgICAgY29uc3QgY3JlZGVudGlhbFByb3ZpZGVyID0gYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgY3JlZGVudGlhbFByb3ZpZGVyLnJlc29sdmVQcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICBpZiAoIWFjY2Vzc0tleUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlc29sdmUgQVdTIGNyZWRlbnRpYWxzIChzZXR1cCB3aXRoIFwiYXdzIGNvbmZpZ3VyZVwiKScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50SWQgPSBhd2FpdCB0aGlzLmFjY291bnRDYWNoZS5mZXRjaChjcmVkcy5hY2Nlc3NLZXlJZCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIG9uZSwgcmVzb2x2ZSBmcm9tIFNUUyBhbmQgc3RvcmUgaW4gY2FjaGUuXG4gICAgICAgIGRlYnVnKCdMb29raW5nIHVwIGRlZmF1bHQgYWNjb3VudCBJRCBmcm9tIFNUUycpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgQVdTLlNUUyh7IGNyZWRlbnRpYWxzOiBjcmVkcywgcmVnaW9uOiBhd2FpdCB0aGlzLnJlZ2lvbiB9KS5nZXRDYWxsZXJJZGVudGl0eSgpLnByb21pc2UoKTtcbiAgICAgICAgY29uc3QgYWlkID0gcmVzdWx0LkFjY291bnQ7XG4gICAgICAgIGlmICghYWlkKSB7XG4gICAgICAgICAgZGVidWcoJ1NUUyBkaWRuXFwndCByZXR1cm4gYW4gYWNjb3VudCBJRCcpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ0RlZmF1bHQgYWNjb3VudCBJRDonLCBhaWQpO1xuICAgICAgICByZXR1cm4gYWlkO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhY2NvdW50SWQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ1VuYWJsZSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgQVdTIGFjY291bnQgKGRpZCB5b3UgY29uZmlndXJlIFwiYXdzIGNvbmZpZ3VyZVwiPyk6JywgZSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGFuIEFXUyBDTEktY29tcGF0aWJsZSBjcmVkZW50aWFsIGNoYWluIHByb3ZpZGVyXG4gKlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWwgcHJvdmlkZXIgY2hhaW4gY3JlYXRlZCBieSB0aGUgU0RLXG4gKiBleGNlcHQgaXQgYWxzbyBhY2NlcHRzIHRoZSBwcm9maWxlIGFyZ3VtZW50IGluIHRoZSBjb25zdHJ1Y3RvciAobm90IGp1c3QgZnJvbVxuICogdGhlIGVudmlyb25tZW50KS5cbiAqXG4gKiBUbyBtaW1pYyB0aGUgQVdTIENMSSBiZWhhdmlvcjpcbiAqXG4gKiAtIHdlIGRlZmF1bHQgdG8gfi8uYXdzL2NyZWRlbnRpYWxzIGlmIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciBjcmVkZW50aWFsc1xuICogZmlsZSBsb2NhdGlvbiBpcyBub3QgZ2l2ZW4gKFNESyBleHBlY3RzIGV4cGxpY2l0IGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggbmFtZSkuXG4gKiAtIEFXU19ERUZBVUxUX1BST0ZJTEUgaXMgYWxzbyBpbnNwZWN0ZWQgZm9yIHByb2ZpbGUgbmFtZSAobm90IGp1c3QgQVdTX1BST0ZJTEUpLlxuICovXG5hc3luYyBmdW5jdGlvbiBtYWtlQ0xJQ29tcGF0aWJsZUNyZWRlbnRpYWxQcm92aWRlcihwcm9maWxlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGVjMmNyZWRzOiBib29sZWFuIHwgdW5kZWZpbmVkKSB7XG4gIHByb2ZpbGUgPSBwcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gIC8vIE5lZWQgdG8gY29uc3RydWN0IGZpbGVuYW1lIG91cnNlbHZlcywgd2l0aG91dCBhcHByb3ByaWF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgLy8gbm8gZGVmYXVsdHMgdXNlZCBieSBKUyBTREsuXG4gIGNvbnN0IGZpbGVuYW1lID0gcHJvY2Vzcy5lbnYuQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFIHx8IHBhdGguam9pbihvcy5ob21lZGlyKCksICcuYXdzJywgJ2NyZWRlbnRpYWxzJyk7XG5cbiAgY29uc3Qgc291cmNlcyA9IFtcbiAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpLFxuICAgICgpID0+IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQU1BWk9OJyksXG4gIF07XG4gIGlmIChmcy5wYXRoRXhpc3RzKGZpbGVuYW1lKSkge1xuICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyh7IHByb2ZpbGUsIGZpbGVuYW1lIH0pKTtcbiAgfVxuXG4gIGlmIChoYXNFY3NDcmVkZW50aWFscygpKSB7XG4gICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUNTQ3JlZGVudGlhbHMoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSBpZjogZG9uJ3QgZ2V0IEVDMiBjcmVkcyBpZiB3ZSBzaG91bGQgaGF2ZSBnb3R0ZW4gRUNTIGNyZWRzLS1FQ1MgaW5zdGFuY2VzIGFsc29cbiAgICAvLyBydW4gb24gRUMyIGJveGVzIGJ1dCB0aGUgY3JlZHMgcmVwcmVzZW50IHNvbWV0aGluZyBkaWZmZXJlbnQuIFNhbWUgYmVoYXZpb3IgYXNcbiAgICAvLyB1cHN0cmVhbSBjb2RlLlxuXG4gICAgaWYgKGVjMmNyZWRzID09PSB1bmRlZmluZWQpIHsgZWMyY3JlZHMgPSBhd2FpdCBoYXNFYzJDcmVkZW50aWFscygpOyB9XG5cbiAgICBpZiAoZWMyY3JlZHMpIHtcbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oc291cmNlcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWZhdWx0IHJlZ2lvbiBpbiBhIENMSS1jb21wYXRpYmxlIHdheVxuICpcbiAqIE1vc3RseSBjb3BpZWQgZnJvbSBub2RlX2xvYWRlci5qcywgYnV0IHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbiAqXG4gKiAtIFRha2VzIGEgcnVudGltZSBwcm9maWxlIG5hbWUgdG8gbG9hZCB0aGUgcmVnaW9uIGZyb20sIG5vdCBqdXN0IGJhc2VkIG9uIGVudmlyb25tZW50XG4gKiAgIHZhcmlhYmxlcyBhdCBwcm9jZXNzIHN0YXJ0LlxuICogLSBXZSBoYXZlIG5lZWRlZCB0byBjcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBTaGFyZWRJbmlGaWxlIGNsYXNzIGJlY2F1c2UgdGhlXG4gKiAgIGltcGxlbWVudGF0aW9uIGluICdhd3Mtc2RrJyBpcyBwcml2YXRlIChhbmQgdGhlIGRlZmF1bHQgdXNlIG9mIGl0IGluIHRoZVxuICogICBTREsgZG9lcyBub3QgYWxsb3cgdXMgdG8gc3BlY2lmeSBhIHByb2ZpbGUgYXQgcnVudGltZSkuXG4gKiAtIEFXU19ERUZBVUxUX1BST0ZJTEUgYW5kIEFXU19ERUZBVUxUX1JFR0lPTiBhcmUgYWxzbyB1c2VkIGFzIGVudmlyb25tZW50XG4gKiAgIHZhcmlhYmxlcyB0byBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcmVnaW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDTElDb21wYXRpYmxlRGVmYXVsdFJlZ2lvbihwcm9maWxlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAvLyBEZWZhdWx0cyBpbnNpZGUgY29uc3RydWN0b3JcbiAgY29uc3QgdG9DaGVjayA9IFtcbiAgICB7ZmlsZW5hbWU6IHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSB9LFxuICAgIHtpc0NvbmZpZzogdHJ1ZSwgZmlsZW5hbWU6IHByb2Nlc3MuZW52LkFXU19DT05GSUdfRklMRX0sXG4gIF07XG5cbiAgbGV0IHJlZ2lvbiA9IHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHwgcHJvY2Vzcy5lbnYuQU1BWk9OX1JFR0lPTiB8fFxuICAgIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT047XG5cbiAgd2hpbGUgKCFyZWdpb24gJiYgdG9DaGVjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29uZmlnRmlsZSA9IG5ldyBTaGFyZWRJbmlGaWxlKHRvQ2hlY2suc2hpZnQoKSk7XG4gICAgY29uc3Qgc2VjdGlvbiA9IGF3YWl0IGNvbmZpZ0ZpbGUuZ2V0UHJvZmlsZShwcm9maWxlKTtcbiAgICByZWdpb24gPSBzZWN0aW9uICYmIHNlY3Rpb24ucmVnaW9uO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2lvbjtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIGNvbmZpZ3VyZWQgSFRUUFMgcHJveHkgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBpdCBsb29rcyBsaWtlIHdlJ2xsIGhhdmUgRUNTIGNyZWRlbnRpYWxzIGF2YWlsYWJsZVxuICovXG5mdW5jdGlvbiBoYXNFY3NDcmVkZW50aWFscygpIHtcbiAgcmV0dXJuIChBV1MuRUNTQ3JlZGVudGlhbHMucHJvdG90eXBlIGFzIGFueSkuaXNDb25maWd1cmVkRm9yRWNzQ3JlZGVudGlhbHMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFzRWMyQ3JlZGVudGlhbHMoKSB7XG4gIGRlYnVnKFwiRGV0ZXJtaW5pbmcgd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2UuXCIpO1xuXG4gIGxldCBpbnN0YW5jZSA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NFQzIvbGF0ZXN0L1dpbmRvd3NHdWlkZS9pZGVudGlmeV9lYzJfaW5zdGFuY2VzLmh0bWxcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1dGlsLnByb21pc2lmeShjaGlsZF9wcm9jZXNzLmV4ZWMpKCd3bWljIHBhdGggd2luMzJfY29tcHV0ZXJzeXN0ZW1wcm9kdWN0IGdldCB1dWlkJywgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAvLyBvdXRwdXQgbG9va3MgbGlrZVxuICAgIC8vICBVVUlEXG4gICAgLy8gIEVDMkFFMTQ1LUQxREMtMTNCMi05NEVELTAxMjM0QUJDREVGXG4gICAgY29uc3QgbGluZXMgPSByZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGluc3RhbmNlID0gbGluZXMuc29tZSh4ID0+IG1hdGNoZXNSZWdleCgvXmVjMi9pLCB4KSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvVXNlckd1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgIGNvbnN0IGZpbGVzOiBBcnJheTxbc3RyaW5nLCBSZWdFeHBdPiA9IFtcbiAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgWGVuIGh5cGVydmlzb3IgYmFzZWQgaW5zdGFuY2VzIChwcmUtNXRoIGdlbilcbiAgICAgIFsnL3N5cy9oeXBlcnZpc29yL3V1aWQnLCAvXmVjMi9pXSxcblxuICAgICAgLy8gVGhpcyByZWNvZ25pemVzIHRoZSBuZXcgSHlwZXJ2aXNvciAoNXRoLWdlbiBpbnN0YW5jZXMgYW5kIGhpZ2hlcilcbiAgICAgIC8vIENhbid0IHVzZSB0aGUgYWR2ZXJ0aXNlZCBmaWxlICcvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF91dWlkJyBiZWNhdXNlIGl0IHJlcXVpcmVzIHJvb3QgdG8gcmVhZC5cbiAgICAgIC8vIEluc3RlYWQsIHN5c192ZW5kb3IgY29udGFpbnMgc29tZXRoaW5nIGxpa2UgJ0FtYXpvbiBFQzInLlxuICAgICAgWycvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvc3lzX3ZlbmRvcicsIC9lYzIvaV0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IFtmaWxlLCByZV0gb2YgZmlsZXMpIHtcbiAgICAgIGlmIChtYXRjaGVzUmVnZXgocmUsIGF3YWl0IHJlYWRJZlBvc3NpYmxlKGZpbGUpKSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKGluc3RhbmNlID8gJ0xvb2tzIGxpa2UgRUMyIGluc3RhbmNlLicgOiAnRG9lcyBub3QgbG9vayBsaWtlIEVDMiBpbnN0YW5jZS4nKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZXRDb25maWdWYXJpYWJsZSgpIHtcbiAgY29uc3QgaG9tZURpciA9IHByb2Nlc3MuZW52LkhPTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEVcbiAgICB8fCAocHJvY2Vzcy5lbnYuSE9NRVBBVEggPyAoKHByb2Nlc3MuZW52LkhPTUVEUklWRSB8fCAnQzovJykgKyBwcm9jZXNzLmVudi5IT01FUEFUSCkgOiBudWxsKSB8fCBvcy5ob21lZGlyKCk7XG5cbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5yZXNvbHZlKGhvbWVEaXIsICcuYXdzJywgJ2NvbmZpZycpKSkge1xuICAgIHByb2Nlc3MuZW52LkFXU19TREtfTE9BRF9DT05GSUcgPSAnMSc7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZElmUG9zc2libGUoZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIHRyeSB7XG4gICAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKGZpbGVuYW1lKSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoZSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzUmVnZXgocmU6IFJlZ0V4cCwgczogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIHJldHVybiBzICE9PSB1bmRlZmluZWQgJiYgcmUuZXhlYyhzKSAhPT0gbnVsbDtcbn1cbiJdfQ==