"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors/safe");
const archive_1 = require("../archive");
const logging_1 = require("../logging");
const credentials_1 = require("./aws-auth/credentials");
const bootstrap_environment_1 = require("./bootstrap-environment");
const cloudformation_1 = require("./util/cloudformation");
class ToolkitInfo {
    constructor(props) {
        this.props = props;
        /**
         * A cache of previous uploads done in this session
         */
        this.previousUploads = {};
        this.sdk = props.sdk;
    }
    get bucketUrl() {
        return `https://${this.props.bucketEndpoint}`;
    }
    get bucketName() {
        return this.props.bucketName;
    }
    /**
     * Uploads a data blob to S3 under the specified key prefix.
     * Uses md5 hash to render the full key and skips upload if an object
     * already exists by this key.
     */
    async uploadIfChanged(data, props) {
        const s3 = await this.props.sdk.s3(this.props.environment, credentials_1.Mode.ForWriting);
        const s3KeyPrefix = props.s3KeyPrefix || '';
        const s3KeySuffix = props.s3KeySuffix || '';
        const bucket = this.props.bucketName;
        const hash = archive_1.md5hash(data);
        const filename = `${hash}${s3KeySuffix}`;
        const key = `${s3KeyPrefix}${filename}`;
        const url = `s3://${bucket}/${key}`;
        logging_1.debug(`${url}: checking if already exists`);
        if (await objectExists(s3, bucket, key)) {
            logging_1.debug(`${url}: found (skipping upload)`);
            return { filename, key, changed: false };
        }
        const uploaded = { filename, key, changed: true };
        // Upload if it's new or server-side copy if it was already uploaded previously
        const previous = this.previousUploads[hash];
        if (previous) {
            logging_1.debug(`${url}: copying`);
            await s3.copyObject({
                Bucket: bucket,
                Key: key,
                CopySource: `${bucket}/${previous.key}`
            }).promise();
            logging_1.debug(`${url}: copy complete`);
        }
        else {
            logging_1.debug(`${url}: uploading`);
            await s3.putObject({
                Bucket: bucket,
                Key: key,
                Body: data,
                ContentType: props.contentType
            }).promise();
            logging_1.debug(`${url}: upload complete`);
            this.previousUploads[hash] = uploaded;
        }
        return uploaded;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     */
    async prepareEcrRepository(assetId) {
        const ecr = await this.props.sdk.ecr(this.props.environment, credentials_1.Mode.ForWriting);
        // Repository name based on asset id
        const repositoryName = 'cdk/' + assetId.replace(/[:/]/g, '-').toLowerCase();
        let repository;
        try {
            logging_1.debug(`${repositoryName}: checking for repository.`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            repository = describeResponse.repositories[0];
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        if (repository) {
            return {
                repositoryUri: repository.repositoryUri,
                repositoryName
            };
        }
        logging_1.debug(`${repositoryName}: creating`);
        const response = await ecr.createRepository({ repositoryName }).promise();
        repository = response.repository;
        // Better put a lifecycle policy on this so as to not cost too much money
        await ecr.putLifecyclePolicy({
            repositoryName,
            lifecyclePolicyText: JSON.stringify(DEFAULT_REPO_LIFECYCLE)
        }).promise();
        return {
            repositoryUri: repository.repositoryUri,
            repositoryName
        };
    }
    /**
     * Get ECR credentials
     */
    async getEcrCredentials() {
        const ecr = await this.props.sdk.ecr(this.props.environment, credentials_1.Mode.ForReading);
        logging_1.debug(`Fetching ECR authorization token`);
        const authData = (await ecr.getAuthorizationToken({}).promise()).authorizationData || [];
        if (authData.length === 0) {
            throw new Error('No authorization data received from ECR');
        }
        const token = Buffer.from(authData[0].authorizationToken, 'base64').toString('ascii');
        const [username, password] = token.split(':');
        return {
            username,
            password,
            endpoint: authData[0].proxyEndpoint,
        };
    }
    /**
     * Check if image already exists in ECR repository
     */
    async checkEcrImage(repositoryName, imageTag) {
        const ecr = await this.props.sdk.ecr(this.props.environment, credentials_1.Mode.ForReading);
        try {
            logging_1.debug(`${repositoryName}: checking for image ${imageTag}`);
            await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
            // If we got here, the image already exists. Nothing else needs to be done.
            return true;
        }
        catch (e) {
            if (e.code !== 'ImageNotFoundException') {
                throw e;
            }
        }
        return false;
    }
}
exports.ToolkitInfo = ToolkitInfo;
async function objectExists(s3, bucket, key) {
    try {
        await s3.headObject({ Bucket: bucket, Key: key }).promise();
        return true;
    }
    catch (e) {
        if (e.code === 'NotFound') {
            return false;
        }
        throw e;
    }
}
async function loadToolkitInfo(environment, sdk, stackName) {
    const cfn = await sdk.cloudFormation(environment, credentials_1.Mode.ForReading);
    const stack = await cloudformation_1.waitForStack(cfn, stackName);
    if (!stack) {
        logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
        return undefined;
    }
    return new ToolkitInfo({
        sdk, environment,
        bucketName: getOutputValue(stack, bootstrap_environment_1.BUCKET_NAME_OUTPUT),
        bucketEndpoint: getOutputValue(stack, bootstrap_environment_1.BUCKET_DOMAIN_NAME_OUTPUT)
    });
}
exports.loadToolkitInfo = loadToolkitInfo;
function getOutputValue(stack, output) {
    let result;
    if (stack.Outputs) {
        const found = stack.Outputs.find(o => o.OutputKey === output);
        result = found && found.OutputValue;
    }
    if (result === undefined) {
        throw new Error(`The CDK toolkit stack (${stack.StackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
    }
    return result;
}
const DEFAULT_REPO_LIFECYCLE = {
    rules: [
        {
            rulePriority: 100,
            description: 'Retain only 5 images',
            selection: {
                tagStatus: 'any',
                countType: 'imageCountMoreThan',
                countNumber: 5,
            },
            action: { type: 'expire' }
        }
    ]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsc0NBQXVDO0FBQ3ZDLHdDQUFxQztBQUNyQyx3Q0FBbUM7QUFDbkMsd0RBQThDO0FBQzlDLG1FQUF5RjtBQUN6RiwwREFBcUQ7QUFlckQsTUFBYSxXQUFXO0lBUXRCLFlBQTZCLEtBSzVCO1FBTDRCLFVBQUssR0FBTCxLQUFLLENBS2pDO1FBVkQ7O1dBRUc7UUFDYyxvQkFBZSxHQUE4QixFQUFFLENBQUM7UUFRL0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxJQUFXLFNBQVM7UUFDbEIsT0FBTyxXQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVELElBQVcsVUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFTLEVBQUUsS0FBa0I7UUFDeEQsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsa0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU1RSxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQztRQUM1QyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQztRQUU1QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztRQUVyQyxNQUFNLElBQUksR0FBRyxpQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNCLE1BQU0sUUFBUSxHQUFHLEdBQUcsSUFBSSxHQUFHLFdB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QTBCLEtBQUssQ0FBQyxTQUFTLG1DQUFtQyxNQUFNLHdDQUF3QyxDQUFDLENBQUM7S0FDN0k7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsTUFBTSxzQkFBc0IsR0FBRztJQUM3QixLQUFLLEVBQUU7UUFDTDtZQUNFLFlBQVksRUFBRSxHQUFHO1lBQ2pCLFdBQVcsRUFBRSxzQkFBc0I7WUFDbkMsU0FBUyxFQUFFO2dCQUNULFNBQVMsRUFBRSxLQUFLO2dCQUNoQixTQUFTLEVBQUUsb0JBQW9CO2dCQUMvQixXQUFXLEVBQUUsQ0FBQzthQUNmO1lBQ0QsTUFBTSxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRTtTQUMzQjtLQUNGO0NBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IGF3cyA9IHJlcXVpcmUoJ2F3cy1zZGsnKTtcbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IHsgbWQ1aGFzaCB9IGZyb20gJy4uL2FyY2hpdmUnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQsIEJVQ0tFVF9OQU1FX09VVFBVVCAgfSBmcm9tICcuL2Jvb3RzdHJhcC1lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyB3YWl0Rm9yU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgU0RLIH0gZnJvbSAnLi91dGlsL3Nkayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkUHJvcHMge1xuICBzM0tleVByZWZpeD86IHN0cmluZyxcbiAgczNLZXlTdWZmaXg/OiBzdHJpbmcsXG4gIGNvbnRlbnRUeXBlPzogc3RyaW5nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZGVkIHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAga2V5OiBzdHJpbmc7XG4gIGNoYW5nZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyByZWFkb25seSBzZGs6IFNESztcblxuICAvKipcbiAgICogQSBjYWNoZSBvZiBwcmV2aW91cyB1cGxvYWRzIGRvbmUgaW4gdGhpcyBzZXNzaW9uXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHByZXZpb3VzVXBsb2Fkczoge1trZXk6IHN0cmluZ106IFVwbG9hZGVkfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IHtcbiAgICBzZGs6IFNESyxcbiAgICBidWNrZXROYW1lOiBzdHJpbmcsXG4gICAgYnVja2V0RW5kcG9pbnQ6IHN0cmluZyxcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnRcbiAgfSkge1xuICAgIHRoaXMuc2RrID0gcHJvcHMuc2RrO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXRVcmwoKSB7XG4gICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5wcm9wcy5idWNrZXRFbmRwb2ludH1gO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmJ1Y2tldE5hbWU7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyBhIGRhdGEgYmxvYiB0byBTMyB1bmRlciB0aGUgc3BlY2lmaWVkIGtleSBwcmVmaXguXG4gICAqIFVzZXMgbWQ1IGhhc2ggdG8gcmVuZGVyIHRoZSBmdWxsIGtleSBhbmQgc2tpcHMgdXBsb2FkIGlmIGFuIG9iamVjdFxuICAgKiBhbHJlYWR5IGV4aXN0cyBieSB0aGlzIGtleS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGxvYWRJZkNoYW5nZWQoZGF0YTogYW55LCBwcm9wczogVXBsb2FkUHJvcHMpOiBQcm9taXNlPFVwbG9hZGVkPiB7XG4gICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLnByb3BzLnNkay5zMyh0aGlzLnByb3BzLmVudmlyb25tZW50LCBNb2RlLkZvcldyaXRpbmcpO1xuXG4gICAgY29uc3QgczNLZXlQcmVmaXggPSBwcm9wcy5zM0tleVByZWZpeCB8fCAnJztcbiAgICBjb25zdCBzM0tleVN1ZmZpeCA9IHByb3BzLnMzS2V5U3VmZml4IHx8ICcnO1xuXG4gICAgY29uc3QgYnVja2V0ID0gdGhpcy5wcm9wcy5idWNrZXROYW1lO1xuXG4gICAgY29uc3QgaGFzaCA9IG1kNWhhc2goZGF0YSk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBgJHtoYXNofSR7czNLZXlTdWZmaXh9YDtcbiAgICBjb25zdCBrZXkgPSBgJHtzM0tleVByZWZpeH0ke2ZpbGVuYW1lfWA7XG4gICAgY29uc3QgdXJsID0gYHMzOi8vJHtidWNrZXR9LyR7a2V5fWA7XG5cbiAgICBkZWJ1ZyhgJHt1cmx9OiBjaGVja2luZyBpZiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIGlmIChhd2FpdCBvYmplY3RFeGlzdHMoczMsIGJ1Y2tldCwga2V5KSkge1xuICAgICAgZGVidWcoYCR7dXJsfTogZm91bmQgKHNraXBwaW5nIHVwbG9hZClgKTtcbiAgICAgIHJldHVybiB7IGZpbGVuYW1lLCBrZXksIGNoYW5nZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkZWQgPSB7IGZpbGVuYW1lLCBrZXksIGNoYW5nZWQ6IHRydWUgfTtcblxuICAgIC8vIFVwbG9hZCBpZiBpdCdzIG5ldyBvciBzZXJ2ZXItc2lkZSBjb3B5IGlmIGl0IHdhcyBhbHJlYWR5IHVwbG9hZGVkIHByZXZpb3VzbHlcbiAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMucHJldmlvdXNVcGxvYWRzW2hhc2hdO1xuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgZGVidWcoYCR7dXJsfTogY29weWluZ2ApO1xuICAgICAgYXdhaXQgczMuY29weU9iamVjdCh7XG4gICAgICAgIEJ1Y2tldDogYnVja2V0LFxuICAgICAgICBLZXk6IGtleSxcbiAgICAgICAgQ29weVNvdXJjZTogYCR7YnVja2V0fS8ke3ByZXZpb3VzLmtleX1gXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgICBkZWJ1ZyhgJHt1cmx9OiBjb3B5IGNvbXBsZXRlYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKGAke3VybH06IHVwbG9hZGluZ2ApO1xuICAgICAgYXdhaXQgczMucHV0T2JqZWN0KHtcbiAgICAgICAgQnVja2V0OiBidWNrZXQsXG4gICAgICAgIEtleToga2V5LFxuICAgICAgICBCb2R5OiBkYXRhLFxuICAgICAgICBDb250ZW50VHlwZTogcHJvcHMuY29udGVudFR5cGVcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgIGRlYnVnKGAke3VybH06IHVwbG9hZCBjb21wbGV0ZWApO1xuICAgICAgdGhpcy5wcmV2aW91c1VwbG9hZHNbaGFzaF0gPSB1cGxvYWRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBsb2FkZWQ7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbiBFQ1IgcmVwb3NpdG9yeSBmb3IgdXBsb2FkaW5nIHRvIHVzaW5nIERvY2tlclxuICAgKi9cbiAgcHVibGljIGFzeW5jIHByZXBhcmVFY3JSZXBvc2l0b3J5KGFzc2V0SWQ6IHN0cmluZyk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0aGlzLnByb3BzLnNkay5lY3IodGhpcy5wcm9wcy5lbnZpcm9ubWVudCwgTW9kZS5Gb3JXcml0aW5nKTtcblxuICAgIC8vIFJlcG9zaXRvcnkgbmFtZSBiYXNlZCBvbiBhc3NldCBpZFxuICAgIGNvbnN0IHJlcG9zaXRvcnlOYW1lID0gJ2Nkay8nICsgYXNzZXRJZC5yZXBsYWNlKC9bOi9dL2csICctJykudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCByZXBvc2l0b3J5O1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGNoZWNraW5nIGZvciByZXBvc2l0b3J5LmApO1xuICAgICAgY29uc3QgZGVzY3JpYmVSZXNwb25zZSA9IGF3YWl0IGVjci5kZXNjcmliZVJlcG9zaXRvcmllcyh7IHJlcG9zaXRvcnlOYW1lczogW3JlcG9zaXRvcnlOYW1lXSB9KS5wcm9taXNlKCk7XG4gICAgICByZXBvc2l0b3J5ID0gZGVzY3JpYmVSZXNwb25zZS5yZXBvc2l0b3JpZXMhWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdSZXBvc2l0b3J5Tm90Rm91bmRFeGNlcHRpb24nKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICBpZiAocmVwb3NpdG9yeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVwb3NpdG9yeVVyaTogcmVwb3NpdG9yeS5yZXBvc2l0b3J5VXJpISxcbiAgICAgICAgcmVwb3NpdG9yeU5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjcmVhdGluZ2ApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWNyLmNyZWF0ZVJlcG9zaXRvcnkoeyByZXBvc2l0b3J5TmFtZSB9KS5wcm9taXNlKCk7XG4gICAgcmVwb3NpdG9yeSA9IHJlc3BvbnNlLnJlcG9zaXRvcnkhO1xuXG4gICAgLy8gQmV0dGVyIHB1dCBhIGxpZmVjeWNsZSBwb2xpY3kgb24gdGhpcyBzbyBhcyB0byBub3QgY29zdCB0b28gbXVjaCBtb25leVxuICAgIGF3YWl0IGVjci5wdXRMaWZlY3ljbGVQb2xpY3koe1xuICAgICAgcmVwb3NpdG9yeU5hbWUsXG4gICAgICBsaWZlY3ljbGVQb2xpY3lUZXh0OiBKU09OLnN0cmluZ2lmeShERUZBVUxUX1JFUE9fTElGRUNZQ0xFKVxuICAgIH0pLnByb21pc2UoKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZXBvc2l0b3J5VXJpOiByZXBvc2l0b3J5LnJlcG9zaXRvcnlVcmkhLFxuICAgICAgcmVwb3NpdG9yeU5hbWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBFQ1IgY3JlZGVudGlhbHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRFY3JDcmVkZW50aWFscygpOiBQcm9taXNlPEVjckNyZWRlbnRpYWxzPiB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgdGhpcy5wcm9wcy5zZGsuZWNyKHRoaXMucHJvcHMuZW52aXJvbm1lbnQsIE1vZGUuRm9yUmVhZGluZyk7XG5cbiAgICBkZWJ1ZyhgRmV0Y2hpbmcgRUNSIGF1dGhvcml6YXRpb24gdG9rZW5gKTtcbiAgICBjb25zdCBhdXRoRGF0YSA9ICAoYXdhaXQgZWNyLmdldEF1dGhvcml6YXRpb25Ub2tlbih7IH0pLnByb21pc2UoKSkuYXV0aG9yaXphdGlvbkRhdGEgfHwgW107XG4gICAgaWYgKGF1dGhEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGRhdGEgcmVjZWl2ZWQgZnJvbSBFQ1InKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBCdWZmZXIuZnJvbShhdXRoRGF0YVswXS5hdXRob3JpemF0aW9uVG9rZW4hLCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSB0b2tlbi5zcGxpdCgnOicpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBlbmRwb2ludDogYXV0aERhdGFbMF0ucHJveHlFbmRwb2ludCEsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbWFnZSBhbHJlYWR5IGV4aXN0cyBpbiBFQ1IgcmVwb3NpdG9yeVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNoZWNrRWNySW1hZ2UocmVwb3NpdG9yeU5hbWU6IHN0cmluZywgaW1hZ2VUYWc6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGVjciA9IGF3YWl0IHRoaXMucHJvcHMuc2RrLmVjcih0aGlzLnByb3BzLmVudmlyb25tZW50LCBNb2RlLkZvclJlYWRpbmcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY2hlY2tpbmcgZm9yIGltYWdlICR7aW1hZ2VUYWd9YCk7XG4gICAgICBhd2FpdCBlY3IuZGVzY3JpYmVJbWFnZXMoeyByZXBvc2l0b3J5TmFtZSwgaW1hZ2VJZHM6IFt7IGltYWdlVGFnIH1dIH0pLnByb21pc2UoKTtcblxuICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZSBpbWFnZSBhbHJlYWR5IGV4aXN0cy4gTm90aGluZyBlbHNlIG5lZWRzIHRvIGJlIGRvbmUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnSW1hZ2VOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVjclJlcG9zaXRvcnlJbmZvIHtcbiAgcmVwb3NpdG9yeVVyaTogc3RyaW5nO1xuICByZXBvc2l0b3J5TmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVjckNyZWRlbnRpYWxzIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgZW5kcG9pbnQ6IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gb2JqZWN0RXhpc3RzKHMzOiBhd3MuUzMsIGJ1Y2tldDogc3RyaW5nLCBrZXk6IHN0cmluZykge1xuICB0cnkge1xuICAgIGF3YWl0IHMzLmhlYWRPYmplY3QoeyBCdWNrZXQ6IGJ1Y2tldCwgS2V5OiBrZXkgfSkucHJvbWlzZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ05vdEZvdW5kJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRUb29sa2l0SW5mbyhlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIHNkazogU0RLLCBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8VG9vbGtpdEluZm8gfMKgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IGNmbiA9IGF3YWl0IHNkay5jbG91ZEZvcm1hdGlvbihlbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nKTtcbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCB3YWl0Rm9yU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgZGVidWcoJ1RoZSBlbnZpcm9ubWVudCAlcyBkb2VzblxcJ3QgaGF2ZSB0aGUgQ0RLIHRvb2xraXQgc3RhY2sgKCVzKSBpbnN0YWxsZWQuIFVzZSAlcyB0byBzZXR1cCB5b3VyIGVudmlyb25tZW50IGZvciB1c2Ugd2l0aCB0aGUgdG9vbGtpdC4nLFxuICAgICAgICBlbnZpcm9ubWVudC5uYW1lLCBzdGFja05hbWUsIGNvbG9ycy5ibHVlKGBjZGsgYm9vdHN0cmFwIFwiJHtlbnZpcm9ubWVudC5uYW1lfVwiYCkpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBUb29sa2l0SW5mbyh7XG4gICAgc2RrLCBlbnZpcm9ubWVudCxcbiAgICBidWNrZXROYW1lOiBnZXRPdXRwdXRWYWx1ZShzdGFjaywgQlVDS0VUX05BTUVfT1VUUFVUKSxcbiAgICBidWNrZXRFbmRwb2ludDogZ2V0T3V0cHV0VmFsdWUoc3RhY2ssIEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRPdXRwdXRWYWx1ZShzdGFjazogYXdzLkNsb3VkRm9ybWF0aW9uLlN0YWNrLCBvdXRwdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCByZXN1bHQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaWYgKHN0YWNrLk91dHB1dHMpIHtcbiAgICBjb25zdCBmb3VuZCA9IHN0YWNrLk91dHB1dHMuZmluZChvID0+IG8uT3V0cHV0S2V5ID09PSBvdXRwdXQpO1xuICAgIHJlc3VsdCA9IGZvdW5kICYmIGZvdW5kLk91dHB1dFZhbHVlO1xuICB9XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIENESyB0b29sa2l0IHN0YWNrICgke3N0YWNrLlN0YWNrTmFtZX0pIGRvZXMgbm90IGhhdmUgYW4gb3V0cHV0IG5hbWVkICR7b3V0cHV0fS4gVXNlICdjZGsgYm9vdHN0cmFwJyB0byBjb3JyZWN0IHRoaXMuYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgREVGQVVMVF9SRVBPX0xJRkVDWUNMRSA9IHtcbiAgcnVsZXM6IFtcbiAgICB7XG4gICAgICBydWxlUHJpb3JpdHk6IDEwMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUmV0YWluIG9ubHkgNSBpbWFnZXMnLFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIHRhZ1N0YXR1czogJ2FueScsXG4gICAgICAgIGNvdW50VHlwZTogJ2ltYWdlQ291bnRNb3JlVGhhbicsXG4gICAgICAgIGNvdW50TnVtYmVyOiA1LFxuICAgICAgfSxcbiAgICAgIGFjdGlvbjogeyB0eXBlOiAnZXhwaXJlJyB9XG4gICAgfVxuICBdXG59O1xuIl19