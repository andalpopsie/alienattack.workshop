"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = require("./encoding");
/**
 * If objects has a function property by this name, they will be considered tokens, and this
 * function will be called to resolve the value for this object.
 */
exports.RESOLVE_METHOD = 'resolve';
/**
 * Represents a special or lazily-evaluated value.
 *
 * Can be used to delay evaluation of a certain value in case, for example,
 * that it requires some context or late-bound data. Can also be used to
 * mark values that need special processing at document rendering time.
 *
 * Tokens can be embedded into strings while retaining their original
 * semantics.
 */
class Token {
    /**
     * Creates a token that resolves to `value`.
     *
     * If value is a function, the function is evaluated upon resolution and
     * the value it returns will be used as the token's value.
     *
     * displayName is used to represent the Token when it's embedded into a string; it
     * will look something like this:
     *
     *    "embedded in a larger string is ${Token[DISPLAY_NAME.123]}"
     *
     * This value is used as a hint to humans what the meaning of the Token is,
     * and does not have any effect on the evaluation.
     *
     * Must contain only alphanumeric and simple separator characters (_.:-).
     *
     * @param valueOrFunction What this token will evaluate to, literal or function.
     * @param displayName A human-readable display hint for this Token
     */
    constructor(valueOrFunction, displayName) {
        this.valueOrFunction = valueOrFunction;
        this.displayName = displayName;
    }
    /**
     * @returns The resolved value for this token.
     */
    resolve(_context) {
        let value = this.valueOrFunction;
        if (typeof (value) === 'function') {
            value = value();
        }
        return value;
    }
    /**
     * Return a reversible string representation of this token
     *
     * If the Token is initialized with a literal, the stringified value of the
     * literal is returned. Otherwise, a special quoted string representation
     * of the Token is returned that can be embedded into other strings.
     *
     * Strings with quoted Tokens in them can be restored back into
     * complex values with the Tokens restored by calling `resolve()`
     * on the string.
     */
    toString() {
        const valueType = typeof this.valueOrFunction;
        // Optimization: if we can immediately resolve this, don't bother
        // registering a Token.
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            return this.valueOrFunction.toString();
        }
        if (this.tokenStringification === undefined) {
            this.tokenStringification = encoding_1.TOKEN_MAP.registerString(this, this.displayName);
        }
        return this.tokenStringification;
    }
    /**
     * Turn this Token into JSON
     *
     * This gets called by JSON.stringify(). We want to prohibit this, because
     * it's not possible to do this properly, so we just throw an error here.
     */
    toJSON() {
        // tslint:disable-next-line:max-line-length
        throw new Error('JSON.stringify() cannot be applied to structure with a Token in it. Use this.node.stringifyJson() instead.');
    }
    /**
     * Return a string list representation of this token
     *
     * Call this if the Token intrinsically evaluates to a list of strings.
     * If so, you can represent the Token in a similar way in the type
     * system.
     *
     * Note that even though the Token is represented as a list of strings, you
     * still cannot do any operations on it such as concatenation, indexing,
     * or taking its length. The only useful operations you can do to these lists
     * is constructing a `FnJoin` or a `FnSelect` on it.
     */
    toList() {
        const valueType = typeof this.valueOrFunction;
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            throw new Error('Got a literal Token value; only intrinsics can ever evaluate to lists.');
        }
        if (this.tokenListification === undefined) {
            this.tokenListification = encoding_1.TOKEN_MAP.registerList(this, this.displayName);
        }
        return this.tokenListification;
    }
}
exports.Token = Token;
/**
 * Whether the given object is an `IResolvedValuePostProcessor`
 */
function isResolvedValuePostProcessor(x) {
    return x.postProcess !== undefined;
}
exports.isResolvedValuePostProcessor = isResolvedValuePostProcessor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0b2tlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHlDQUF1QztBQUV2Qzs7O0dBR0c7QUFDVSxRQUFBLGNBQWMsR0FBRyxTQUFTLENBQUM7QUFFeEM7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxLQUFLO0lBWWhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7SUFDSCxZQUE2QixlQUFxQixFQUFtQixXQUFvQjtRQUE1RCxvQkFBZSxHQUFmLGVBQWUsQ0FBTTtRQUFtQixnQkFBVyxHQUFYLFdBQVcsQ0FBUztJQUN6RixDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPLENBQUMsUUFBd0I7UUFDckMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUNqQyxJQUFJLE9BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxVQUFVLEVBQUU7WUFDaEMsS0FBSyxHQUFHLEtBQUssRUFBRSxDQUFDO1NBQ2pCO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLFFBQVE7UUFDYixNQUFNLFNBQVMsR0FBRyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDOUMsaUVBQWlFO1FBQ2pFLHVCQUF1QjtRQUN2QixJQUFJLFNBQVMsS0FBSyxRQUFRLElBQUksU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQy9FLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUN4QztRQUVELElBQUksSUFBSSxDQUFDLG9CQUFvQixLQUFLLFNBQVMsRUFBRTtZQUMzQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsb0JBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUM5RTtRQUNELE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDO0lBQ25DLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU07UUFDWCwyQ0FBMkM7UUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyw0R0FBNEcsQ0FBQyxDQUFDO0lBQ2hJLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLE1BQU07UUFDWCxNQUFNLFNBQVMsR0FBRyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDOUMsSUFBSSxTQUFTLEtBQUssUUFBUSxJQUFJLFNBQVMsS0FBSyxRQUFRLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtZQUMvRSxNQUFNLElBQUksS0FBSyxDQUFDLHdFQUF3RSxDQUFDLENBQUM7U0FDM0Y7UUFFRCxJQUFJLElBQUksQ0FBQyxrQkFBa0IsS0FBSyxTQUFTLEVBQUU7WUFDekMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLG9CQUFTLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDMUU7UUFDRCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztJQUNqQyxDQUFDO0NBQ0Y7QUF6R0Qsc0JBeUdDO0FBb0JEOztHQUVHO0FBQ0gsU0FBZ0IsNEJBQTRCLENBQUMsQ0FBTTtJQUNqRCxPQUFPLENBQUMsQ0FBQyxXQUFXLEtBQUssU0FBUyxDQUFDO0FBQ3JDLENBQUM7QUFGRCxvRUFFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElDb25zdHJ1Y3QgfSBmcm9tIFwiLi4vY29uc3RydWN0XCI7XG5pbXBvcnQgeyBUT0tFTl9NQVAgfSBmcm9tIFwiLi9lbmNvZGluZ1wiO1xuXG4vKipcbiAqIElmIG9iamVjdHMgaGFzIGEgZnVuY3Rpb24gcHJvcGVydHkgYnkgdGhpcyBuYW1lLCB0aGV5IHdpbGwgYmUgY29uc2lkZXJlZCB0b2tlbnMsIGFuZCB0aGlzXG4gKiBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byByZXNvbHZlIHRoZSB2YWx1ZSBmb3IgdGhpcyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBSRVNPTFZFX01FVEhPRCA9ICdyZXNvbHZlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lhbCBvciBsYXppbHktZXZhbHVhdGVkIHZhbHVlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGRlbGF5IGV2YWx1YXRpb24gb2YgYSBjZXJ0YWluIHZhbHVlIGluIGNhc2UsIGZvciBleGFtcGxlLFxuICogdGhhdCBpdCByZXF1aXJlcyBzb21lIGNvbnRleHQgb3IgbGF0ZS1ib3VuZCBkYXRhLiBDYW4gYWxzbyBiZSB1c2VkIHRvXG4gKiBtYXJrIHZhbHVlcyB0aGF0IG5lZWQgc3BlY2lhbCBwcm9jZXNzaW5nIGF0IGRvY3VtZW50IHJlbmRlcmluZyB0aW1lLlxuICpcbiAqIFRva2VucyBjYW4gYmUgZW1iZWRkZWQgaW50byBzdHJpbmdzIHdoaWxlIHJldGFpbmluZyB0aGVpciBvcmlnaW5hbFxuICogc2VtYW50aWNzLlxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciB0aGlzIFRva2VuIHJlcHJlc2VudCBhIFwicmVmZXJlbmNlXCJcbiAgICpcbiAgICogVGhlIENvbnN0cnVjdCB0cmVlIGNhbiBiZSBxdWVyaWVkIGZvciB0aGUgUmVmZXJlbmNlIFRva2VucyB0aGF0XG4gICAqIGFyZSB1c2VkIGluIGl0LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGlzUmVmZXJlbmNlPzogYm9vbGVhbjtcblxuICBwcml2YXRlIHRva2VuU3RyaW5naWZpY2F0aW9uPzogc3RyaW5nO1xuICBwcml2YXRlIHRva2VuTGlzdGlmaWNhdGlvbj86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdG9rZW4gdGhhdCByZXNvbHZlcyB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIHVwb24gcmVzb2x1dGlvbiBhbmRcbiAgICogdGhlIHZhbHVlIGl0IHJldHVybnMgd2lsbCBiZSB1c2VkIGFzIHRoZSB0b2tlbidzIHZhbHVlLlxuICAgKlxuICAgKiBkaXNwbGF5TmFtZSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgVG9rZW4gd2hlbiBpdCdzIGVtYmVkZGVkIGludG8gYSBzdHJpbmc7IGl0XG4gICAqIHdpbGwgbG9vayBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgKlxuICAgKiAgICBcImVtYmVkZGVkIGluIGEgbGFyZ2VyIHN0cmluZyBpcyAke1Rva2VuW0RJU1BMQVlfTkFNRS4xMjNdfVwiXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgaXMgdXNlZCBhcyBhIGhpbnQgdG8gaHVtYW5zIHdoYXQgdGhlIG1lYW5pbmcgb2YgdGhlIFRva2VuIGlzLFxuICAgKiBhbmQgZG9lcyBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBldmFsdWF0aW9uLlxuICAgKlxuICAgKiBNdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgYW5kIHNpbXBsZSBzZXBhcmF0b3IgY2hhcmFjdGVycyAoXy46LSkuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZU9yRnVuY3Rpb24gV2hhdCB0aGlzIHRva2VuIHdpbGwgZXZhbHVhdGUgdG8sIGxpdGVyYWwgb3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBkaXNwbGF5TmFtZSBBIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXkgaGludCBmb3IgdGhpcyBUb2tlblxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB2YWx1ZU9yRnVuY3Rpb24/OiBhbnksIHByaXZhdGUgcmVhZG9ubHkgZGlzcGxheU5hbWU/OiBzdHJpbmcpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoaXMgdG9rZW4uXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZShfY29udGV4dDogUmVzb2x2ZUNvbnRleHQpOiBhbnkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVPckZ1bmN0aW9uO1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJldmVyc2libGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdG9rZW5cbiAgICpcbiAgICogSWYgdGhlIFRva2VuIGlzIGluaXRpYWxpemVkIHdpdGggYSBsaXRlcmFsLCB0aGUgc3RyaW5naWZpZWQgdmFsdWUgb2YgdGhlXG4gICAqIGxpdGVyYWwgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBzcGVjaWFsIHF1b3RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIFRva2VuIGlzIHJldHVybmVkIHRoYXQgY2FuIGJlIGVtYmVkZGVkIGludG8gb3RoZXIgc3RyaW5ncy5cbiAgICpcbiAgICogU3RyaW5ncyB3aXRoIHF1b3RlZCBUb2tlbnMgaW4gdGhlbSBjYW4gYmUgcmVzdG9yZWQgYmFjayBpbnRvXG4gICAqIGNvbXBsZXggdmFsdWVzIHdpdGggdGhlIFRva2VucyByZXN0b3JlZCBieSBjYWxsaW5nIGByZXNvbHZlKClgXG4gICAqIG9uIHRoZSBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdGhpcy52YWx1ZU9yRnVuY3Rpb247XG4gICAgLy8gT3B0aW1pemF0aW9uOiBpZiB3ZSBjYW4gaW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGlzLCBkb24ndCBib3RoZXJcbiAgICAvLyByZWdpc3RlcmluZyBhIFRva2VuLlxuICAgIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnIHx8IHZhbHVlVHlwZSA9PT0gJ251bWJlcicgfHwgdmFsdWVUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlT3JGdW5jdGlvbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuU3RyaW5naWZpY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudG9rZW5TdHJpbmdpZmljYXRpb24gPSBUT0tFTl9NQVAucmVnaXN0ZXJTdHJpbmcodGhpcywgdGhpcy5kaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuU3RyaW5naWZpY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gdGhpcyBUb2tlbiBpbnRvIEpTT05cbiAgICpcbiAgICogVGhpcyBnZXRzIGNhbGxlZCBieSBKU09OLnN0cmluZ2lmeSgpLiBXZSB3YW50IHRvIHByb2hpYml0IHRoaXMsIGJlY2F1c2VcbiAgICogaXQncyBub3QgcG9zc2libGUgdG8gZG8gdGhpcyBwcm9wZXJseSwgc28gd2UganVzdCB0aHJvdyBhbiBlcnJvciBoZXJlLlxuICAgKi9cbiAgcHVibGljIHRvSlNPTigpOiBhbnkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5KCkgY2Fubm90IGJlIGFwcGxpZWQgdG8gc3RydWN0dXJlIHdpdGggYSBUb2tlbiBpbiBpdC4gVXNlIHRoaXMubm9kZS5zdHJpbmdpZnlKc29uKCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzdHJpbmcgbGlzdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRva2VuXG4gICAqXG4gICAqIENhbGwgdGhpcyBpZiB0aGUgVG9rZW4gaW50cmluc2ljYWxseSBldmFsdWF0ZXMgdG8gYSBsaXN0IG9mIHN0cmluZ3MuXG4gICAqIElmIHNvLCB5b3UgY2FuIHJlcHJlc2VudCB0aGUgVG9rZW4gaW4gYSBzaW1pbGFyIHdheSBpbiB0aGUgdHlwZVxuICAgKiBzeXN0ZW0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCBldmVuIHRob3VnaCB0aGUgVG9rZW4gaXMgcmVwcmVzZW50ZWQgYXMgYSBsaXN0IG9mIHN0cmluZ3MsIHlvdVxuICAgKiBzdGlsbCBjYW5ub3QgZG8gYW55IG9wZXJhdGlvbnMgb24gaXQgc3VjaCBhcyBjb25jYXRlbmF0aW9uLCBpbmRleGluZyxcbiAgICogb3IgdGFraW5nIGl0cyBsZW5ndGguIFRoZSBvbmx5IHVzZWZ1bCBvcGVyYXRpb25zIHlvdSBjYW4gZG8gdG8gdGhlc2UgbGlzdHNcbiAgICogaXMgY29uc3RydWN0aW5nIGEgYEZuSm9pbmAgb3IgYSBgRm5TZWxlY3RgIG9uIGl0LlxuICAgKi9cbiAgcHVibGljIHRvTGlzdCgpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHRoaXMudmFsdWVPckZ1bmN0aW9uO1xuICAgIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnIHx8IHZhbHVlVHlwZSA9PT0gJ251bWJlcicgfHwgdmFsdWVUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR290IGEgbGl0ZXJhbCBUb2tlbiB2YWx1ZTsgb25seSBpbnRyaW5zaWNzIGNhbiBldmVyIGV2YWx1YXRlIHRvIGxpc3RzLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuTGlzdGlmaWNhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRva2VuTGlzdGlmaWNhdGlvbiA9IFRPS0VOX01BUC5yZWdpc3Rlckxpc3QodGhpcywgdGhpcy5kaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuTGlzdGlmaWNhdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEN1cnJlbnQgcmVzb2x1dGlvbiBjb250ZXh0IGZvciB0b2tlbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlQ29udGV4dCB7XG4gIHNjb3BlOiBJQ29uc3RydWN0O1xuICBwcmVmaXg6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEEgVG9rZW4gdGhhdCBjYW4gcG9zdC1wcm9jZXNzIHRoZSBjb21wbGV0ZSByZXNvbHZlZCB2YWx1ZSwgYWZ0ZXIgcmVzb2x2ZSgpIGhhcyByZWN1cnNlZCBvdmVyIGl0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVJlc29sdmVkVmFsdWVQb3N0UHJvY2Vzc29yIHtcbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIGNvbXBsZXRlbHkgcmVzb2x2ZWQgdmFsdWUsIGFmdGVyIGZ1bGwgcmVjdXJzaW9uL3Jlc29sdXRpb24gaGFzIGhhcHBlbmVkXG4gICAqL1xuICBwb3N0UHJvY2VzcyhpbnB1dDogYW55LCBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCk6IGFueTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gYElSZXNvbHZlZFZhbHVlUG9zdFByb2Nlc3NvcmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzb2x2ZWRWYWx1ZVBvc3RQcm9jZXNzb3IoeDogYW55KTogeCBpcyBJUmVzb2x2ZWRWYWx1ZVBvc3RQcm9jZXNzb3Ige1xuICByZXR1cm4geC5wb3N0UHJvY2VzcyAhPT0gdW5kZWZpbmVkO1xufSJdfQ==