"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const app_1 = require("../app");
const construct_1 = require("../core/construct");
const cfn_tokens_1 = require("./cfn-tokens");
const logical_id_1 = require("./logical-id");
/**
 * A root construct which represents a single CloudFormation stack.
 */
class Stack extends construct_1.Construct {
    /**
     * Creates a new stack.
     *
     * @param scope Parent of this stack, usually a Program instance.
     * @param name The name of the CloudFormation stack. Defaults to "Stack".
     * @param props Stack properties.
     */
    constructor(scope, name, props) {
        // For unit test convenience parents are optional, so bypass the type check when calling the parent.
        super(scope, name);
        this.props = props;
        /**
         * Lists all missing contextual information.
         * This is returned when the stack is synthesized under the 'missing' attribute
         * and allows tooling to obtain the context and re-synthesize.
         */
        this.missingContext = {};
        /**
         * Options for CloudFormation template (like version, transform, description).
         */
        this.templateOptions = {};
        /*
         * Used to determine if this construct is a stack.
         */
        this._isStack = true;
        /**
         * Other stacks this stack depends on
         */
        this.stackDependencies = new Set();
        /**
         * Values set for parameters in cloud assembly.
         */
        this.parameterValues = {};
        if (name && !Stack.VALID_STACK_NAME_REGEX.test(name)) {
            throw new Error(`Stack name must match the regular expression: ${Stack.VALID_STACK_NAME_REGEX.toString()}, got '${name}'`);
        }
        this.env = this.parseEnvironment(props);
        this.logicalIds = new logical_id_1.LogicalIDs(props && props.namingScheme ? props.namingScheme : new logical_id_1.HashedAddressingScheme());
        this.name = this.node.id;
    }
    /**
     * Adds a metadata annotation "aws:cdk:physical-name" to the construct if physicalName
     * is non-null. This can be used later by tools and aspects to determine if resources
     * have been created with physical names.
     */
    static annotatePhysicalName(construct, physicalName) {
        if (physicalName == null) {
            return;
        }
        construct.node.addMetadata('aws:cdk:physical-name', physicalName);
    }
    /**
     * Return whether the given object is a Stack.
     *
     * We do attribute detection since we can't reliably use 'instanceof'.
     */
    static isStack(construct) {
        return construct._isStack;
    }
    /**
     * Returns the environment specification for this stack (aws://account/region).
     */
    get environment() {
        const account = this.env.account || 'unknown-account';
        const region = this.env.region || 'unknown-region';
        return `aws://${account}/${region}`;
    }
    /**
     * Looks up a resource by path.
     *
     * @returns The Resource or undefined if not found
     */
    findResource(path) {
        const r = this.node.findChild(path);
        if (!r) {
            return undefined;
        }
        // found an element, check if it's a resource (duck-type)
        if (!('resourceType' in r)) {
            throw new Error(`Found a stack element for ${path} but it is not a resource: ${r.toString()}`);
        }
        return r;
    }
    /**
     * Returns the CloudFormation template for this stack by traversing
     * the tree and invoking toCloudFormation() on all Entity objects.
     */
    toCloudFormation() {
        // before we begin synthesis, we shall lock this stack, so children cannot be added
        this.node.lock();
        try {
            const template = {
                Description: this.templateOptions.description,
                Transform: this.templateOptions.transform,
                AWSTemplateFormatVersion: this.templateOptions.templateFormatVersion,
                Metadata: this.templateOptions.metadata
            };
            const elements = stackElements(this);
            const fragments = elements.map(e => this.node.resolve(e.toCloudFormation()));
            // merge in all CloudFormation fragments collected from the tree
            for (const fragment of fragments) {
                merge(template, fragment);
            }
            // resolve all tokens and remove all empties
            const ret = this.node.resolve(template) || {};
            this.logicalIds.assertAllRenamesApplied();
            return ret;
        }
        finally {
            // allow mutations after synthesis is finished.
            this.node.unlock();
        }
    }
    /**
     * @param why more information about why region is required.
     * @returns The region in which this stack is deployed. Throws if region is not defined.
     */
    requireRegion(why) {
        if (!this.env.region) {
            throw new Error(`${why ? why + '. ' : ''}Stack requires region information. It can be either supplied via the "env" property, ` +
                `via the "${cxapi.DEFAULT_REGION_CONTEXT_KEY}" context parameters or using "aws configure"`);
        }
        return this.env.region;
    }
    /**
     * Returns the AWS account ID of this Stack,
     * or throws an exception if the account ID is not set in the environment.
     *
     * @param why more information about why is the account ID required
     * @returns the AWS account ID of this Stack
     */
    requireAccountId(why) {
        if (!this.env.account) {
            throw new Error(`${why ? why + '. ' : ''}Stack requires account information. ` +
                'It can be supplied either via the "env" property when creating the Stack, or by using "aws configure"');
        }
        return this.env.account;
    }
    parentApp() {
        const parent = this.node.scope;
        return parent instanceof app_1.App
            ? parent
            : undefined;
    }
    /**
     * Indicate that a context key was expected
     *
     * Contains instructions on how the key should be supplied.
     * @param key Key that uniquely identifies this missing context.
     * @param details The set of parameters needed to obtain the context (specific to context provider).
     */
    reportMissingContext(key, details) {
        this.missingContext[key] = details;
    }
    /**
     * Rename a generated logical identities
     */
    renameLogical(oldId, newId) {
        if (this.node.children.length > 0) {
            throw new Error("All renames must be set up before adding elements to the stack");
        }
        this.logicalIds.renameLogical(oldId, newId);
    }
    /**
     * Add a dependency between this stack and another stack
     */
    addDependency(stack) {
        if (stack.dependsOnStack(this)) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`Stack '${this.name}' already depends on stack '${stack.name}'. Adding this dependency would create a cyclic reference.`);
        }
        this.stackDependencies.add(stack);
    }
    /**
     * Return the stacks this stack depends on
     */
    dependencies() {
        return Array.from(this.stackDependencies.values());
    }
    /**
     * The account in which this stack is defined
     *
     * Either returns the literal account for this stack if it was specified
     * literally upon Stack construction, or a symbolic value that will evaluate
     * to the correct account at deployment time.
     */
    get accountId() {
        if (this.props && this.props.env && this.props.env.account) {
            return this.props.env.account;
        }
        // Does not need to be scoped, the only situation in which
        // Export/Fn::ImportValue would work if { Ref: "AWS::AccountId" } is the
        // same for provider and consumer anyway.
        return pseudo_1.Aws.accountId;
    }
    /**
     * The region in which this stack is defined
     *
     * Either returns the literal region for this stack if it was specified
     * literally upon Stack construction, or a symbolic value that will evaluate
     * to the correct region at deployment time.
     */
    get region() {
        if (this.props && this.props.env && this.props.env.region) {
            return this.props.env.region;
        }
        // Does not need to be scoped, the only situation in which
        // Export/Fn::ImportValue would work if { Ref: "AWS::AccountId" } is the
        // same for provider and consumer anyway.
        return pseudo_1.Aws.region;
    }
    /**
     * The partition in which this stack is defined
     */
    get partition() {
        // Always return a non-scoped partition intrinsic. These will usually
        // be used to construct an ARN, but there are no cross-partition
        // calls anyway.
        return pseudo_1.Aws.partition;
    }
    /**
     * The Amazon domain suffix for the region in which this stack is defined
     */
    get urlSuffix() {
        return new pseudo_1.ScopedAws(this).urlSuffix;
    }
    /**
     * The ID of the stack
     *
     * @example After resolving, looks like arn:aws:cloudformation:us-west-2:123456789012:stack/teststack/51af3dc0-da77-11e4-872e-1234567db123
     */
    get stackId() {
        return new pseudo_1.ScopedAws(this).stackId;
    }
    /**
     * The name of the stack currently being deployed
     *
     * Only available at deployment time.
     */
    get stackName() {
        return new pseudo_1.ScopedAws(this).stackName;
    }
    /**
     * Returns the list of notification Amazon Resource Names (ARNs) for the current stack.
     */
    get notificationArns() {
        return new pseudo_1.ScopedAws(this).notificationArns;
    }
    /**
     * Creates an ARN from components.
     *
     * If `partition`, `region` or `account` are not specified, the stack's
     * partition, region and account will be used.
     *
     * If any component is the empty string, an empty string will be inserted
     * into the generated ARN at the location that component corresponds to.
     *
     * The ARN will be formatted as follows:
     *
     *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}}{resource-name}
     *
     * The required ARN pieces that are omitted will be taken from the stack that
     * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope
     * can be 'undefined'.
     */
    formatArn(components) {
        return arn_1.arnFromComponents(components, this);
    }
    /**
     * Given an ARN, parses it and returns components.
     *
     * If the ARN is a concrete string, it will be parsed and validated. The
     * separator (`sep`) will be set to '/' if the 6th component includes a '/',
     * in which case, `resource` will be set to the value before the '/' and
     * `resourceName` will be the rest. In case there is no '/', `resource` will
     * be set to the 6th components and `resourceName` will be set to the rest
     * of the string.
     *
     * If the ARN includes tokens (or is a token), the ARN cannot be validated,
     * since we don't have the actual value yet at the time of this function
     * call. You will have to know the separator and the type of ARN. The
     * resulting `ArnComponents` object will contain tokens for the
     * subexpressions of the ARN, not string literals. In this case this
     * function cannot properly parse the complete final resourceName (path) out
     * of ARNs that use '/' to both separate the 'resource' from the
     * 'resourceName' AND to subdivide the resourceName further. For example, in
     * S3 ARNs:
     *
     *    arn:aws:s3:::my_corporate_bucket/path/to/exampleobject.png
     *
     * After parsing the resourceName will not contain
     * 'path/to/exampleobject.png' but simply 'path'. This is a limitation
     * because there is no slicing functionality in CloudFormation templates.
     *
     * @param sep The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all. For
     * example, SNS Topics ARNs have the 'resource' component contain the topic
     * name, and no 'resourceName' component.
     *
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     *
     * @returns an ArnComponents object which allows access to the various
     *      components of the ARN.
     */
    parseArn(arn, sepIfToken = '/', hasName = true) {
        return arn_1.parseArn(arn, sepIfToken, hasName);
    }
    /**
     * Sets the value of a CloudFormation parameter.
     * @param parameter The parameter to set the value for
     * @param value The value, can use `${}` notation to reference other assembly block attributes.
     */
    setParameterValue(parameter, value) {
        this.parameterValues[parameter.logicalId] = value;
    }
    /**
     * Validate stack name
     *
     * CloudFormation stack names can include dashes in addition to the regular identifier
     * character classes, and we don't allow one of the magic markers.
     */
    _validateId(name) {
        if (name && !Stack.VALID_STACK_NAME_REGEX.test(name)) {
            throw new Error(`Stack name must match the regular expression: ${Stack.VALID_STACK_NAME_REGEX.toString()}, got '${name}'`);
        }
    }
    /**
     * Prepare stack
     *
     * Find all CloudFormation references and tell them we're consuming them.
     *
     * Find all dependencies as well and add the appropriate DependsOn fields.
     */
    prepare() {
        // References
        for (const ref of this.node.findReferences()) {
            if (cfn_tokens_1.CfnReference.isCfnReference(ref)) {
                ref.consumeFromStack(this);
            }
        }
        // Resource dependencies
        for (const dependency of this.node.findDependencies()) {
            const theirStack = dependency.target.node.stack;
            if (theirStack !== undefined && theirStack !== this) {
                this.addDependency(theirStack);
            }
            else {
                for (const target of findResources([dependency.target])) {
                    for (const source of findResources([dependency.source])) {
                        source.addDependsOn(target);
                    }
                }
            }
        }
    }
    synthesize(session) {
        const template = `${this.node.id}.template.json`;
        // write the CloudFormation template as a JSON file
        session.store.writeJson(template, this.toCloudFormation());
        const artifact = {
            type: cxapi.ArtifactType.AwsCloudFormationStack,
            environment: this.environment,
            properties: {
                templateFile: template,
            }
        };
        if (Object.keys(this.parameterValues).length > 0) {
            artifact.properties = artifact.properties || {};
            artifact.properties.parameters = this.node.resolve(this.parameterValues);
        }
        const deps = this.dependencies().map(s => s.node.id);
        if (deps.length > 0) {
            artifact.dependencies = deps;
        }
        const meta = this.collectMetadata();
        if (Object.keys(meta).length > 0) {
            artifact.metadata = meta;
        }
        if (this.missingContext && Object.keys(this.missingContext).length > 0) {
            artifact.missing = this.missingContext;
        }
        // add an artifact that represents this stack
        session.addArtifact(this.node.id, artifact);
    }
    /**
     * Applied defaults to environment attributes.
     */
    parseEnvironment(props) {
        // start with `env`.
        const env = (props && props.env) || {};
        // if account is not specified, attempt to read from context.
        if (!env.account) {
            env.account = this.node.getContext(cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY);
        }
        // if region is not specified, attempt to read from context.
        if (!env.region) {
            env.region = this.node.getContext(cxapi.DEFAULT_REGION_CONTEXT_KEY);
        }
        return env;
    }
    /**
     * Check whether this stack has a (transitive) dependency on another stack
     */
    dependsOnStack(other) {
        if (this === other) {
            return true;
        }
        for (const dep of this.stackDependencies) {
            if (dep.dependsOnStack(other)) {
                return true;
            }
        }
        return false;
    }
    collectMetadata() {
        const output = {};
        visit(this);
        const app = this.parentApp();
        if (app && app.node.metadata.length > 0) {
            output[construct_1.PATH_SEP] = app.node.metadata;
        }
        return output;
        function visit(node) {
            if (node.node.metadata.length > 0) {
                // Make the path absolute
                output[construct_1.PATH_SEP + node.node.path] = node.node.metadata.map(md => node.node.resolve(md));
            }
            for (const child of node.node.children) {
                visit(child);
            }
        }
    }
}
Stack.VALID_STACK_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-]*$/;
exports.Stack = Stack;
function merge(template, part) {
    for (const section of Object.keys(part)) {
        const src = part[section];
        // create top-level section if it doesn't exist
        let dest = template[section];
        if (!dest) {
            template[section] = dest = src;
        }
        else {
            // add all entities from source section to destination section
            for (const id of Object.keys(src)) {
                if (id in dest) {
                    throw new Error(`section '${section}' already contains '${id}'`);
                }
                dest[id] = src[id];
            }
        }
    }
}
/**
 * Collect all StackElements from a construct
 *
 * @param node Root node to collect all StackElements from
 * @param into Array to append StackElements to
 * @returns The same array as is being collected into
 */
function stackElements(node, into = []) {
    if (stack_element_1.StackElement.isStackElement(node)) {
        into.push(node);
    }
    for (const child of node.node.children) {
        stackElements(child, into);
    }
    return into;
}
// These imports have to be at the end to prevent circular imports
const arn_1 = require("./arn");
const pseudo_1 = require("./pseudo");
const resource_1 = require("./resource");
const stack_element_1 = require("./stack-element");
/**
 * Find all resources in a set of constructs
 */
function findResources(roots) {
    const ret = new Array();
    for (const root of roots) {
        ret.push(...root.node.findAll().filter(resource_1.Resource.isResource));
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUEwQztBQUMxQyxnQ0FBNkI7QUFDN0IsaURBQW9FO0FBR3BFLDZDQUE0QztBQUM1Qyw2Q0FBcUY7QUFvQnJGOztHQUVHO0FBQ0gsTUFBYSxLQUFNLFNBQVEscUJBQVM7SUFtRWxDOzs7Ozs7T0FNRztJQUNILFlBQW1CLEtBQVcsRUFBRSxJQUFhLEVBQW1CLEtBQWtCO1FBQ2hGLG9HQUFvRztRQUNwRyxLQUFLLENBQUMsS0FBTSxFQUFFLElBQUssQ0FBQyxDQUFDO1FBRnlDLFVBQUssR0FBTCxLQUFLLENBQWE7UUFqRGxGOzs7O1dBSUc7UUFDYSxtQkFBYyxHQUE0QyxFQUFHLENBQUM7UUFZOUU7O1dBRUc7UUFDYSxvQkFBZSxHQUFvQixFQUFFLENBQUM7UUFPdEQ7O1dBRUc7UUFDZ0IsYUFBUSxHQUFHLElBQUksQ0FBQztRQUVuQzs7V0FFRztRQUNjLHNCQUFpQixHQUFHLElBQUksR0FBRyxFQUFTLENBQUM7UUFFdEQ7O1dBRUc7UUFDYyxvQkFBZSxHQUFvQyxFQUFHLENBQUM7UUFhdEUsSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3BELE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLEVBQUUsVUFBVSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQzVIO1FBRUQsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFeEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLHVCQUFVLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksbUNBQXNCLEVBQUUs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KCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCB7IEFwcCB9IGZyb20gJy4uL2FwcCc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QsIElDb25zdHJ1Y3QsIFBBVEhfU0VQIH0gZnJvbSAnLi4vY29yZS9jb25zdHJ1Y3QnO1xuaW1wb3J0IHsgRW52aXJvbm1lbnQgfSBmcm9tICcuLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyBJU3ludGhlc2lzU2Vzc2lvbiB9IGZyb20gJy4uL3N5bnRoZXNpcyc7XG5pbXBvcnQgeyBDZm5SZWZlcmVuY2UgfSBmcm9tICcuL2Nmbi10b2tlbnMnO1xuaW1wb3J0IHsgSGFzaGVkQWRkcmVzc2luZ1NjaGVtZSwgSUFkZHJlc3NpbmdTY2hlbWUsIExvZ2ljYWxJRHMgfSBmcm9tICcuL2xvZ2ljYWwtaWQnO1xuaW1wb3J0IHsgUGFyYW1ldGVyIH0gZnJvbSAnLi9wYXJhbWV0ZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrUHJvcHMge1xuICAvKipcbiAgICogVGhlIEFXUyBlbnZpcm9ubWVudCAoYWNjb3VudC9yZWdpb24pIHdoZXJlIHRoaXMgc3RhY2sgd2lsbCBiZSBkZXBsb3llZC5cbiAgICpcbiAgICogSWYgbm90IHN1cHBsaWVkLCB0aGUgYGRlZmF1bHQtYWNjb3VudGAgYW5kIGBkZWZhdWx0LXJlZ2lvbmAgY29udGV4dCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICogdXNlZC4gSWYgdGhleSBhcmUgdW5kZWZpbmVkLCBpdCB3aWxsIG5vdCBiZSBwb3NzaWJsZSB0byBkZXBsb3kgdGhlIHN0YWNrLlxuICAgKi9cbiAgZW52PzogRW52aXJvbm1lbnQ7XG5cbiAgLyoqXG4gICAqIFN0cmF0ZWd5IGZvciBsb2dpY2FsIElEIGdlbmVyYXRpb25cbiAgICpcbiAgICogT3B0aW9uYWwuIElmIG5vdCBzdXBwbGllZCwgdGhlIEhhc2hlZE5hbWluZ1NjaGVtZSB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBuYW1pbmdTY2hlbWU/OiBJQWRkcmVzc2luZ1NjaGVtZTtcbn1cblxuLyoqXG4gKiBBIHJvb3QgY29uc3RydWN0IHdoaWNoIHJlcHJlc2VudHMgYSBzaW5nbGUgQ2xvdWRGb3JtYXRpb24gc3RhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFjayBleHRlbmRzIENvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBBZGRzIGEgbWV0YWRhdGEgYW5ub3RhdGlvbiBcImF3czpjZGs6cGh5c2ljYWwtbmFtZVwiIHRvIHRoZSBjb25zdHJ1Y3QgaWYgcGh5c2ljYWxOYW1lXG4gICAqIGlzIG5vbi1udWxsLiBUaGlzIGNhbiBiZSB1c2VkIGxhdGVyIGJ5IHRvb2xzIGFuZCBhc3BlY3RzIHRvIGRldGVybWluZSBpZiByZXNvdXJjZXNcbiAgICogaGF2ZSBiZWVuIGNyZWF0ZWQgd2l0aCBwaHlzaWNhbCBuYW1lcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYW5ub3RhdGVQaHlzaWNhbE5hbWUoY29uc3RydWN0OiBDb25zdHJ1Y3QsIHBoeXNpY2FsTmFtZT86IHN0cmluZykge1xuICAgIGlmIChwaHlzaWNhbE5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdC5ub2RlLmFkZE1ldGFkYXRhKCdhd3M6Y2RrOnBoeXNpY2FsLW5hbWUnLCBwaHlzaWNhbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBTdGFjay5cbiAgICpcbiAgICogV2UgZG8gYXR0cmlidXRlIGRldGVjdGlvbiBzaW5jZSB3ZSBjYW4ndCByZWxpYWJseSB1c2UgJ2luc3RhbmNlb2YnLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc1N0YWNrKGNvbnN0cnVjdDogSUNvbnN0cnVjdCk6IGNvbnN0cnVjdCBpcyBTdGFjayB7XG4gICAgcmV0dXJuIChjb25zdHJ1Y3QgYXMgYW55KS5faXNTdGFjaztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFZBTElEX1NUQUNLX05BTUVfUkVHRVggPSAvXltBLVphLXpdW0EtWmEtejAtOS1dKiQvO1xuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgbWlzc2luZyBjb250ZXh0dWFsIGluZm9ybWF0aW9uLlxuICAgKiBUaGlzIGlzIHJldHVybmVkIHdoZW4gdGhlIHN0YWNrIGlzIHN5bnRoZXNpemVkIHVuZGVyIHRoZSAnbWlzc2luZycgYXR0cmlidXRlXG4gICAqIGFuZCBhbGxvd3MgdG9vbGluZyB0byBvYnRhaW4gdGhlIGNvbnRleHQgYW5kIHJlLXN5bnRoZXNpemUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbWlzc2luZ0NvbnRleHQ6IHsgW2tleTogc3RyaW5nXTogY3hhcGkuTWlzc2luZ0NvbnRleHQgfSA9IHsgfTtcblxuICAvKipcbiAgICogVGhlIGVudmlyb25tZW50IGluIHdoaWNoIHRoaXMgc3RhY2sgaXMgZGVwbG95ZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudDtcblxuICAvKipcbiAgICogTG9naWNhbCBJRCBnZW5lcmF0aW9uIHN0cmF0ZWd5XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbG9naWNhbElkczogTG9naWNhbElEcztcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgKGxpa2UgdmVyc2lvbiwgdHJhbnNmb3JtLCBkZXNjcmlwdGlvbikuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdGVtcGxhdGVPcHRpb25zOiBUZW1wbGF0ZU9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIENsb3VkRm9ybWF0aW9uIHN0YWNrIG5hbWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qXG4gICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgY29uc3RydWN0IGlzIGEgc3RhY2suXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2lzU3RhY2sgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBPdGhlciBzdGFja3MgdGhpcyBzdGFjayBkZXBlbmRzIG9uXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrRGVwZW5kZW5jaWVzID0gbmV3IFNldDxTdGFjaz4oKTtcblxuICAvKipcbiAgICogVmFsdWVzIHNldCBmb3IgcGFyYW1ldGVycyBpbiBjbG91ZCBhc3NlbWJseS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcGFyYW1ldGVyVmFsdWVzOiB7IFtsb2dpY2FsSWQ6IHN0cmluZ106IHN0cmluZyB9ID0geyB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGUgUGFyZW50IG9mIHRoaXMgc3RhY2ssIHVzdWFsbHkgYSBQcm9ncmFtIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgQ2xvdWRGb3JtYXRpb24gc3RhY2suIERlZmF1bHRzIHRvIFwiU3RhY2tcIi5cbiAgICogQHBhcmFtIHByb3BzIFN0YWNrIHByb3BlcnRpZXMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2NvcGU/OiBBcHAsIG5hbWU/OiBzdHJpbmcsIHByaXZhdGUgcmVhZG9ubHkgcHJvcHM/OiBTdGFja1Byb3BzKSB7XG4gICAgLy8gRm9yIHVuaXQgdGVzdCBjb252ZW5pZW5jZSBwYXJlbnRzIGFyZSBvcHRpb25hbCwgc28gYnlwYXNzIHRoZSB0eXBlIGNoZWNrIHdoZW4gY2FsbGluZyB0aGUgcGFyZW50LlxuICAgIHN1cGVyKHNjb3BlISwgbmFtZSEpO1xuXG4gICAgaWYgKG5hbWUgJiYgIVN0YWNrLlZBTElEX1NUQUNLX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGFjayBuYW1lIG11c3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbjogJHtTdGFjay5WQUxJRF9TVEFDS19OQU1FX1JFR0VYLnRvU3RyaW5nKCl9LCBnb3QgJyR7bmFtZX0nYCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbnYgPSB0aGlzLnBhcnNlRW52aXJvbm1lbnQocHJvcHMpO1xuXG4gICAgdGhpcy5sb2dpY2FsSWRzID0gbmV3IExvZ2ljYWxJRHMocHJvcHMgJiYgcHJvcHMubmFtaW5nU2NoZW1lID8gcHJvcHMubmFtaW5nU2NoZW1lIDogbmV3IEhhc2hlZEFkZHJlc3NpbmdTY2hlbWUoKSk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5ub2RlLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVudmlyb25tZW50IHNwZWNpZmljYXRpb24gZm9yIHRoaXMgc3RhY2sgKGF3czovL2FjY291bnQvcmVnaW9uKS5cbiAgICovXG4gIHB1YmxpYyBnZXQgZW52aXJvbm1lbnQoKSB7XG4gICAgY29uc3QgYWNjb3VudCA9IHRoaXMuZW52LmFjY291bnQgfHwgJ3Vua25vd24tYWNjb3VudCc7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5lbnYucmVnaW9uIHx8ICd1bmtub3duLXJlZ2lvbic7XG4gICAgcmV0dXJuIGBhd3M6Ly8ke2FjY291bnR9LyR7cmVnaW9ufWA7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdXAgYSByZXNvdXJjZSBieSBwYXRoLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgUmVzb3VyY2Ugb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGZpbmRSZXNvdXJjZShwYXRoOiBzdHJpbmcpOiBSZXNvdXJjZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgciA9IHRoaXMubm9kZS5maW5kQ2hpbGQocGF0aCk7XG4gICAgaWYgKCFyKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgIC8vIGZvdW5kIGFuIGVsZW1lbnQsIGNoZWNrIGlmIGl0J3MgYSByZXNvdXJjZSAoZHVjay10eXBlKVxuICAgIGlmICghKCdyZXNvdXJjZVR5cGUnIGluIHIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGEgc3RhY2sgZWxlbWVudCBmb3IgJHtwYXRofSBidXQgaXQgaXMgbm90IGEgcmVzb3VyY2U6ICR7ci50b1N0cmluZygpfWApO1xuICAgIH1cblxuICAgIHJldHVybiByIGFzIFJlc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGZvciB0aGlzIHN0YWNrIGJ5IHRyYXZlcnNpbmdcbiAgICogdGhlIHRyZWUgYW5kIGludm9raW5nIHRvQ2xvdWRGb3JtYXRpb24oKSBvbiBhbGwgRW50aXR5IG9iamVjdHMuXG4gICAqL1xuICBwdWJsaWMgdG9DbG91ZEZvcm1hdGlvbigpIHtcbiAgICAvLyBiZWZvcmUgd2UgYmVnaW4gc3ludGhlc2lzLCB3ZSBzaGFsbCBsb2NrIHRoaXMgc3RhY2ssIHNvIGNoaWxkcmVuIGNhbm5vdCBiZSBhZGRlZFxuICAgIHRoaXMubm9kZS5sb2NrKCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdGVtcGxhdGU6IGFueSA9IHtcbiAgICAgICAgRGVzY3JpcHRpb246IHRoaXMudGVtcGxhdGVPcHRpb25zLmRlc2NyaXB0aW9uLFxuICAgICAgICBUcmFuc2Zvcm06IHRoaXMudGVtcGxhdGVPcHRpb25zLnRyYW5zZm9ybSxcbiAgICAgICAgQVdTVGVtcGxhdGVGb3JtYXRWZXJzaW9uOiB0aGlzLnRlbXBsYXRlT3B0aW9ucy50ZW1wbGF0ZUZvcm1hdFZlcnNpb24sXG4gICAgICAgIE1ldGFkYXRhOiB0aGlzLnRlbXBsYXRlT3B0aW9ucy5tZXRhZGF0YVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZWxlbWVudHMgPSBzdGFja0VsZW1lbnRzKHRoaXMpO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gZWxlbWVudHMubWFwKGUgPT4gdGhpcy5ub2RlLnJlc29sdmUoZS50b0Nsb3VkRm9ybWF0aW9uKCkpKTtcblxuICAgICAgLy8gbWVyZ2UgaW4gYWxsIENsb3VkRm9ybWF0aW9uIGZyYWdtZW50cyBjb2xsZWN0ZWQgZnJvbSB0aGUgdHJlZVxuICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbWVyZ2UodGVtcGxhdGUsIGZyYWdtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzb2x2ZSBhbGwgdG9rZW5zIGFuZCByZW1vdmUgYWxsIGVtcHRpZXNcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMubm9kZS5yZXNvbHZlKHRlbXBsYXRlKSB8fCB7fTtcblxuICAgICAgdGhpcy5sb2dpY2FsSWRzLmFzc2VydEFsbFJlbmFtZXNBcHBsaWVkKCk7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsbG93IG11dGF0aW9ucyBhZnRlciBzeW50aGVzaXMgaXMgZmluaXNoZWQuXG4gICAgICB0aGlzLm5vZGUudW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB3aHkgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aHkgcmVnaW9uIGlzIHJlcXVpcmVkLlxuICAgKiBAcmV0dXJucyBUaGUgcmVnaW9uIGluIHdoaWNoIHRoaXMgc3RhY2sgaXMgZGVwbG95ZWQuIFRocm93cyBpZiByZWdpb24gaXMgbm90IGRlZmluZWQuXG4gICAqL1xuICBwdWJsaWMgcmVxdWlyZVJlZ2lvbih3aHk/OiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZW52LnJlZ2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3doeSA/IHdoeSArICcuICcgOiAnJ31TdGFjayByZXF1aXJlcyByZWdpb24gaW5mb3JtYXRpb24uIEl0IGNhbiBiZSBlaXRoZXIgc3VwcGxpZWQgdmlhIHRoZSBcImVudlwiIHByb3BlcnR5LCBgICtcbiAgICAgICAgICBgdmlhIHRoZSBcIiR7Y3hhcGkuREVGQVVMVF9SRUdJT05fQ09OVEVYVF9LRVl9XCIgY29udGV4dCBwYXJhbWV0ZXJzIG9yIHVzaW5nIFwiYXdzIGNvbmZpZ3VyZVwiYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW52LnJlZ2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBBV1MgYWNjb3VudCBJRCBvZiB0aGlzIFN0YWNrLFxuICAgKiBvciB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBhY2NvdW50IElEIGlzIG5vdCBzZXQgaW4gdGhlIGVudmlyb25tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gd2h5IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgd2h5IGlzIHRoZSBhY2NvdW50IElEIHJlcXVpcmVkXG4gICAqIEByZXR1cm5zIHRoZSBBV1MgYWNjb3VudCBJRCBvZiB0aGlzIFN0YWNrXG4gICAqL1xuICBwdWJsaWMgcmVxdWlyZUFjY291bnRJZCh3aHk/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5lbnYuYWNjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3doeSA/IHdoeSArICcuICcgOiAnJ31TdGFjayByZXF1aXJlcyBhY2NvdW50IGluZm9ybWF0aW9uLiBgICtcbiAgICAgICAgJ0l0IGNhbiBiZSBzdXBwbGllZCBlaXRoZXIgdmlhIHRoZSBcImVudlwiIHByb3BlcnR5IHdoZW4gY3JlYXRpbmcgdGhlIFN0YWNrLCBvciBieSB1c2luZyBcImF3cyBjb25maWd1cmVcIicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVudi5hY2NvdW50O1xuICB9XG5cbiAgcHVibGljIHBhcmVudEFwcCgpOiBBcHAgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMubm9kZS5zY29wZTtcbiAgICByZXR1cm4gcGFyZW50IGluc3RhbmNlb2YgQXBwXG4gICAgICA/IHBhcmVudFxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGUgdGhhdCBhIGNvbnRleHQga2V5IHdhcyBleHBlY3RlZFxuICAgKlxuICAgKiBDb250YWlucyBpbnN0cnVjdGlvbnMgb24gaG93IHRoZSBrZXkgc2hvdWxkIGJlIHN1cHBsaWVkLlxuICAgKiBAcGFyYW0ga2V5IEtleSB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBtaXNzaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBkZXRhaWxzIFRoZSBzZXQgb2YgcGFyYW1ldGVycyBuZWVkZWQgdG8gb2J0YWluIHRoZSBjb250ZXh0IChzcGVjaWZpYyB0byBjb250ZXh0IHByb3ZpZGVyKS5cbiAgICovXG4gIHB1YmxpYyByZXBvcnRNaXNzaW5nQ29udGV4dChrZXk6IHN0cmluZywgZGV0YWlsczogY3hhcGkuTWlzc2luZ0NvbnRleHQpIHtcbiAgICB0aGlzLm1pc3NpbmdDb250ZXh0W2tleV0gPSBkZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhIGdlbmVyYXRlZCBsb2dpY2FsIGlkZW50aXRpZXNcbiAgICovXG4gIHB1YmxpYyByZW5hbWVMb2dpY2FsKG9sZElkOiBzdHJpbmcsIG5ld0lkOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCByZW5hbWVzIG11c3QgYmUgc2V0IHVwIGJlZm9yZSBhZGRpbmcgZWxlbWVudHMgdG8gdGhlIHN0YWNrXCIpO1xuICAgIH1cblxuICAgIHRoaXMubG9naWNhbElkcy5yZW5hbWVMb2dpY2FsKG9sZElkLCBuZXdJZCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoaXMgc3RhY2sgYW5kIGFub3RoZXIgc3RhY2tcbiAgICovXG4gIHB1YmxpYyBhZGREZXBlbmRlbmN5KHN0YWNrOiBTdGFjaykge1xuICAgIGlmIChzdGFjay5kZXBlbmRzT25TdGFjayh0aGlzKSkge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhY2sgJyR7dGhpcy5uYW1lfScgYWxyZWFkeSBkZXBlbmRzIG9uIHN0YWNrICcke3N0YWNrLm5hbWV9Jy4gQWRkaW5nIHRoaXMgZGVwZW5kZW5jeSB3b3VsZCBjcmVhdGUgYSBjeWNsaWMgcmVmZXJlbmNlLmApO1xuICAgIH1cbiAgICB0aGlzLnN0YWNrRGVwZW5kZW5jaWVzLmFkZChzdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdGFja3MgdGhpcyBzdGFjayBkZXBlbmRzIG9uXG4gICAqL1xuICBwdWJsaWMgZGVwZW5kZW5jaWVzKCk6IFN0YWNrW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RhY2tEZXBlbmRlbmNpZXMudmFsdWVzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhY2NvdW50IGluIHdoaWNoIHRoaXMgc3RhY2sgaXMgZGVmaW5lZFxuICAgKlxuICAgKiBFaXRoZXIgcmV0dXJucyB0aGUgbGl0ZXJhbCBhY2NvdW50IGZvciB0aGlzIHN0YWNrIGlmIGl0IHdhcyBzcGVjaWZpZWRcbiAgICogbGl0ZXJhbGx5IHVwb24gU3RhY2sgY29uc3RydWN0aW9uLCBvciBhIHN5bWJvbGljIHZhbHVlIHRoYXQgd2lsbCBldmFsdWF0ZVxuICAgKiB0byB0aGUgY29ycmVjdCBhY2NvdW50IGF0IGRlcGxveW1lbnQgdGltZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgYWNjb3VudElkKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMucHJvcHMgJiYgdGhpcy5wcm9wcy5lbnYgJiYgdGhpcy5wcm9wcy5lbnYuYWNjb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZW52LmFjY291bnQ7XG4gICAgfVxuICAgIC8vIERvZXMgbm90IG5lZWQgdG8gYmUgc2NvcGVkLCB0aGUgb25seSBzaXR1YXRpb24gaW4gd2hpY2hcbiAgICAvLyBFeHBvcnQvRm46OkltcG9ydFZhbHVlIHdvdWxkIHdvcmsgaWYgeyBSZWY6IFwiQVdTOjpBY2NvdW50SWRcIiB9IGlzIHRoZVxuICAgIC8vIHNhbWUgZm9yIHByb3ZpZGVyIGFuZCBjb25zdW1lciBhbnl3YXkuXG4gICAgcmV0dXJuIEF3cy5hY2NvdW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlZ2lvbiBpbiB3aGljaCB0aGlzIHN0YWNrIGlzIGRlZmluZWRcbiAgICpcbiAgICogRWl0aGVyIHJldHVybnMgdGhlIGxpdGVyYWwgcmVnaW9uIGZvciB0aGlzIHN0YWNrIGlmIGl0IHdhcyBzcGVjaWZpZWRcbiAgICogbGl0ZXJhbGx5IHVwb24gU3RhY2sgY29uc3RydWN0aW9uLCBvciBhIHN5bWJvbGljIHZhbHVlIHRoYXQgd2lsbCBldmFsdWF0ZVxuICAgKiB0byB0aGUgY29ycmVjdCByZWdpb24gYXQgZGVwbG95bWVudCB0aW1lLlxuICAgKi9cbiAgcHVibGljIGdldCByZWdpb24oKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5wcm9wcyAmJiB0aGlzLnByb3BzLmVudiAmJiB0aGlzLnByb3BzLmVudi5yZWdpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmVudi5yZWdpb247XG4gICAgfVxuICAgIC8vIERvZXMgbm90IG5lZWQgdG8gYmUgc2NvcGVkLCB0aGUgb25seSBzaXR1YXRpb24gaW4gd2hpY2hcbiAgICAvLyBFeHBvcnQvRm46OkltcG9ydFZhbHVlIHdvdWxkIHdvcmsgaWYgeyBSZWY6IFwiQVdTOjpBY2NvdW50SWRcIiB9IGlzIHRoZVxuICAgIC8vIHNhbWUgZm9yIHByb3ZpZGVyIGFuZCBjb25zdW1lciBhbnl3YXkuXG4gICAgcmV0dXJuIEF3cy5yZWdpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBhcnRpdGlvbiBpbiB3aGljaCB0aGlzIHN0YWNrIGlzIGRlZmluZWRcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFydGl0aW9uKCk6IHN0cmluZyB7XG4gICAgLy8gQWx3YXlzIHJldHVybiBhIG5vbi1zY29wZWQgcGFydGl0aW9uIGludHJpbnNpYy4gVGhlc2Ugd2lsbCB1c3VhbGx5XG4gICAgLy8gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYW4gQVJOLCBidXQgdGhlcmUgYXJlIG5vIGNyb3NzLXBhcnRpdGlvblxuICAgIC8vIGNhbGxzIGFueXdheS5cbiAgICByZXR1cm4gQXdzLnBhcnRpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQW1hem9uIGRvbWFpbiBzdWZmaXggZm9yIHRoZSByZWdpb24gaW4gd2hpY2ggdGhpcyBzdGFjayBpcyBkZWZpbmVkXG4gICAqL1xuICBwdWJsaWMgZ2V0IHVybFN1ZmZpeCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBuZXcgU2NvcGVkQXdzKHRoaXMpLnVybFN1ZmZpeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHN0YWNrXG4gICAqXG4gICAqIEBleGFtcGxlIEFmdGVyIHJlc29sdmluZywgbG9va3MgbGlrZSBhcm46YXdzOmNsb3VkZm9ybWF0aW9uOnVzLXdlc3QtMjoxMjM0NTY3ODkwMTI6c3RhY2svdGVzdHN0YWNrLzUxYWYzZGMwLWRhNzctMTFlNC04NzJlLTEyMzQ1NjdkYjEyM1xuICAgKi9cbiAgcHVibGljIGdldCBzdGFja0lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBTY29wZWRBd3ModGhpcykuc3RhY2tJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgc3RhY2sgY3VycmVudGx5IGJlaW5nIGRlcGxveWVkXG4gICAqXG4gICAqIE9ubHkgYXZhaWxhYmxlIGF0IGRlcGxveW1lbnQgdGltZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBTY29wZWRBd3ModGhpcykuc3RhY2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygbm90aWZpY2F0aW9uIEFtYXpvbiBSZXNvdXJjZSBOYW1lcyAoQVJOcykgZm9yIHRoZSBjdXJyZW50IHN0YWNrLlxuICAgKi9cbiAgcHVibGljIGdldCBub3RpZmljYXRpb25Bcm5zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlZEF3cyh0aGlzKS5ub3RpZmljYXRpb25Bcm5zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQVJOIGZyb20gY29tcG9uZW50cy5cbiAgICpcbiAgICogSWYgYHBhcnRpdGlvbmAsIGByZWdpb25gIG9yIGBhY2NvdW50YCBhcmUgbm90IHNwZWNpZmllZCwgdGhlIHN0YWNrJ3NcbiAgICogcGFydGl0aW9uLCByZWdpb24gYW5kIGFjY291bnQgd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBJZiBhbnkgY29tcG9uZW50IGlzIHRoZSBlbXB0eSBzdHJpbmcsIGFuIGVtcHR5IHN0cmluZyB3aWxsIGJlIGluc2VydGVkXG4gICAqIGludG8gdGhlIGdlbmVyYXRlZCBBUk4gYXQgdGhlIGxvY2F0aW9uIHRoYXQgY29tcG9uZW50IGNvcnJlc3BvbmRzIHRvLlxuICAgKlxuICAgKiBUaGUgQVJOIHdpbGwgYmUgZm9ybWF0dGVkIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICAgYXJuOntwYXJ0aXRpb259OntzZXJ2aWNlfTp7cmVnaW9ufTp7YWNjb3VudH06e3Jlc291cmNlfXtzZXB9fXtyZXNvdXJjZS1uYW1lfVxuICAgKlxuICAgKiBUaGUgcmVxdWlyZWQgQVJOIHBpZWNlcyB0aGF0IGFyZSBvbWl0dGVkIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGUgc3RhY2sgdGhhdFxuICAgKiB0aGUgJ3Njb3BlJyBpcyBhdHRhY2hlZCB0by4gSWYgYWxsIEFSTiBwaWVjZXMgYXJlIHN1cHBsaWVkLCB0aGUgc3VwcGxpZWQgc2NvcGVcbiAgICogY2FuIGJlICd1bmRlZmluZWQnLlxuICAgKi9cbiAgcHVibGljIGZvcm1hdEFybihjb21wb25lbnRzOiBBcm5Db21wb25lbnRzKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYXJuRnJvbUNvbXBvbmVudHMoY29tcG9uZW50cywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gQVJOLCBwYXJzZXMgaXQgYW5kIHJldHVybnMgY29tcG9uZW50cy5cbiAgICpcbiAgICogSWYgdGhlIEFSTiBpcyBhIGNvbmNyZXRlIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYW5kIHZhbGlkYXRlZC4gVGhlXG4gICAqIHNlcGFyYXRvciAoYHNlcGApIHdpbGwgYmUgc2V0IHRvICcvJyBpZiB0aGUgNnRoIGNvbXBvbmVudCBpbmNsdWRlcyBhICcvJyxcbiAgICogaW4gd2hpY2ggY2FzZSwgYHJlc291cmNlYCB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUgYmVmb3JlIHRoZSAnLycgYW5kXG4gICAqIGByZXNvdXJjZU5hbWVgIHdpbGwgYmUgdGhlIHJlc3QuIEluIGNhc2UgdGhlcmUgaXMgbm8gJy8nLCBgcmVzb3VyY2VgIHdpbGxcbiAgICogYmUgc2V0IHRvIHRoZSA2dGggY29tcG9uZW50cyBhbmQgYHJlc291cmNlTmFtZWAgd2lsbCBiZSBzZXQgdG8gdGhlIHJlc3RcbiAgICogb2YgdGhlIHN0cmluZy5cbiAgICpcbiAgICogSWYgdGhlIEFSTiBpbmNsdWRlcyB0b2tlbnMgKG9yIGlzIGEgdG9rZW4pLCB0aGUgQVJOIGNhbm5vdCBiZSB2YWxpZGF0ZWQsXG4gICAqIHNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIGFjdHVhbCB2YWx1ZSB5ZXQgYXQgdGhlIHRpbWUgb2YgdGhpcyBmdW5jdGlvblxuICAgKiBjYWxsLiBZb3Ugd2lsbCBoYXZlIHRvIGtub3cgdGhlIHNlcGFyYXRvciBhbmQgdGhlIHR5cGUgb2YgQVJOLiBUaGVcbiAgICogcmVzdWx0aW5nIGBBcm5Db21wb25lbnRzYCBvYmplY3Qgd2lsbCBjb250YWluIHRva2VucyBmb3IgdGhlXG4gICAqIHN1YmV4cHJlc3Npb25zIG9mIHRoZSBBUk4sIG5vdCBzdHJpbmcgbGl0ZXJhbHMuIEluIHRoaXMgY2FzZSB0aGlzXG4gICAqIGZ1bmN0aW9uIGNhbm5vdCBwcm9wZXJseSBwYXJzZSB0aGUgY29tcGxldGUgZmluYWwgcmVzb3VyY2VOYW1lIChwYXRoKSBvdXRcbiAgICogb2YgQVJOcyB0aGF0IHVzZSAnLycgdG8gYm90aCBzZXBhcmF0ZSB0aGUgJ3Jlc291cmNlJyBmcm9tIHRoZVxuICAgKiAncmVzb3VyY2VOYW1lJyBBTkQgdG8gc3ViZGl2aWRlIHRoZSByZXNvdXJjZU5hbWUgZnVydGhlci4gRm9yIGV4YW1wbGUsIGluXG4gICAqIFMzIEFSTnM6XG4gICAqXG4gICAqICAgIGFybjphd3M6czM6OjpteV9jb3Jwb3JhdGVfYnVja2V0L3BhdGgvdG8vZXhhbXBsZW9iamVjdC5wbmdcbiAgICpcbiAgICogQWZ0ZXIgcGFyc2luZyB0aGUgcmVzb3VyY2VOYW1lIHdpbGwgbm90IGNvbnRhaW5cbiAgICogJ3BhdGgvdG8vZXhhbXBsZW9iamVjdC5wbmcnIGJ1dCBzaW1wbHkgJ3BhdGgnLiBUaGlzIGlzIGEgbGltaXRhdGlvblxuICAgKiBiZWNhdXNlIHRoZXJlIGlzIG5vIHNsaWNpbmcgZnVuY3Rpb25hbGl0eSBpbiBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzZXAgVGhlIHNlcGFyYXRvciB1c2VkIHRvIHNlcGFyYXRlIHJlc291cmNlIGZyb20gcmVzb3VyY2VOYW1lXG4gICAqIEBwYXJhbSBoYXNOYW1lIFdoZXRoZXIgdGhlcmUgaXMgYSBuYW1lIGNvbXBvbmVudCBpbiB0aGUgQVJOIGF0IGFsbC4gRm9yXG4gICAqIGV4YW1wbGUsIFNOUyBUb3BpY3MgQVJOcyBoYXZlIHRoZSAncmVzb3VyY2UnIGNvbXBvbmVudCBjb250YWluIHRoZSB0b3BpY1xuICAgKiBuYW1lLCBhbmQgbm8gJ3Jlc291cmNlTmFtZScgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBBcm5Db21wb25lbnRzIG9iamVjdCB3aGljaCBhbGxvd3MgYWNjZXNzIHRvIHRoZSB2YXJpb3VzXG4gICAqIGNvbXBvbmVudHMgb2YgdGhlIEFSTi5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJuQ29tcG9uZW50cyBvYmplY3Qgd2hpY2ggYWxsb3dzIGFjY2VzcyB0byB0aGUgdmFyaW91c1xuICAgKiAgICAgIGNvbXBvbmVudHMgb2YgdGhlIEFSTi5cbiAgICovXG4gIHB1YmxpYyBwYXJzZUFybihhcm46IHN0cmluZywgc2VwSWZUb2tlbjogc3RyaW5nID0gJy8nLCBoYXNOYW1lOiBib29sZWFuID0gdHJ1ZSk6IEFybkNvbXBvbmVudHMge1xuICAgIHJldHVybiBwYXJzZUFybihhcm4sIHNlcElmVG9rZW4sIGhhc05hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgQ2xvdWRGb3JtYXRpb24gcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSwgY2FuIHVzZSBgJHt9YCBub3RhdGlvbiB0byByZWZlcmVuY2Ugb3RoZXIgYXNzZW1ibHkgYmxvY2sgYXR0cmlidXRlcy5cbiAgICovXG4gIHB1YmxpYyBzZXRQYXJhbWV0ZXJWYWx1ZShwYXJhbWV0ZXI6IFBhcmFtZXRlciwgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMucGFyYW1ldGVyVmFsdWVzW3BhcmFtZXRlci5sb2dpY2FsSWRdID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgc3RhY2sgbmFtZVxuICAgKlxuICAgKiBDbG91ZEZvcm1hdGlvbiBzdGFjayBuYW1lcyBjYW4gaW5jbHVkZSBkYXNoZXMgaW4gYWRkaXRpb24gdG8gdGhlIHJlZ3VsYXIgaWRlbnRpZmllclxuICAgKiBjaGFyYWN0ZXIgY2xhc3NlcywgYW5kIHdlIGRvbid0IGFsbG93IG9uZSBvZiB0aGUgbWFnaWMgbWFya2Vycy5cbiAgICovXG4gIHByb3RlY3RlZCBfdmFsaWRhdGVJZChuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAobmFtZSAmJiAhU3RhY2suVkFMSURfU1RBQ0tfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YWNrIG5hbWUgbXVzdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uOiAke1N0YWNrLlZBTElEX1NUQUNLX05BTUVfUkVHRVgudG9TdHJpbmcoKX0sIGdvdCAnJHtuYW1lfSdgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBzdGFja1xuICAgKlxuICAgKiBGaW5kIGFsbCBDbG91ZEZvcm1hdGlvbiByZWZlcmVuY2VzIGFuZCB0ZWxsIHRoZW0gd2UncmUgY29uc3VtaW5nIHRoZW0uXG4gICAqXG4gICAqIEZpbmQgYWxsIGRlcGVuZGVuY2llcyBhcyB3ZWxsIGFuZCBhZGQgdGhlIGFwcHJvcHJpYXRlIERlcGVuZHNPbiBmaWVsZHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgcHJlcGFyZSgpIHtcbiAgICAvLyBSZWZlcmVuY2VzXG4gICAgZm9yIChjb25zdCByZWYgb2YgdGhpcy5ub2RlLmZpbmRSZWZlcmVuY2VzKCkpIHtcbiAgICAgIGlmIChDZm5SZWZlcmVuY2UuaXNDZm5SZWZlcmVuY2UocmVmKSkge1xuICAgICAgICByZWYuY29uc3VtZUZyb21TdGFjayh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNvdXJjZSBkZXBlbmRlbmNpZXNcbiAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgdGhpcy5ub2RlLmZpbmREZXBlbmRlbmNpZXMoKSkge1xuICAgICAgY29uc3QgdGhlaXJTdGFjayA9IGRlcGVuZGVuY3kudGFyZ2V0Lm5vZGUuc3RhY2s7XG4gICAgICBpZiAodGhlaXJTdGFjayAhPT0gdW5kZWZpbmVkICYmIHRoZWlyU3RhY2sgIT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5hZGREZXBlbmRlbmN5KHRoZWlyU3RhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgZmluZFJlc291cmNlcyhbZGVwZW5kZW5jeS50YXJnZXRdKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGZpbmRSZXNvdXJjZXMoW2RlcGVuZGVuY3kuc291cmNlXSkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5hZGREZXBlbmRzT24odGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc3ludGhlc2l6ZShzZXNzaW9uOiBJU3ludGhlc2lzU2Vzc2lvbik6IHZvaWQge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYCR7dGhpcy5ub2RlLmlkfS50ZW1wbGF0ZS5qc29uYDtcblxuICAgIC8vIHdyaXRlIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBhcyBhIEpTT04gZmlsZVxuICAgIHNlc3Npb24uc3RvcmUud3JpdGVKc29uKHRlbXBsYXRlLCB0aGlzLnRvQ2xvdWRGb3JtYXRpb24oKSk7XG5cbiAgICBjb25zdCBhcnRpZmFjdDogY3hhcGkuQXJ0aWZhY3QgPSB7XG4gICAgICB0eXBlOiBjeGFwaS5BcnRpZmFjdFR5cGUuQXdzQ2xvdWRGb3JtYXRpb25TdGFjayxcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLmVudmlyb25tZW50LFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0ZW1wbGF0ZUZpbGU6IHRlbXBsYXRlLFxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5wYXJhbWV0ZXJWYWx1ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGFydGlmYWN0LnByb3BlcnRpZXMgPSBhcnRpZmFjdC5wcm9wZXJ0aWVzIHx8IHsgfTtcbiAgICAgIGFydGlmYWN0LnByb3BlcnRpZXMucGFyYW1ldGVycyA9IHRoaXMubm9kZS5yZXNvbHZlKHRoaXMucGFyYW1ldGVyVmFsdWVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXBzID0gdGhpcy5kZXBlbmRlbmNpZXMoKS5tYXAocyA9PiBzLm5vZGUuaWQpO1xuICAgIGlmIChkZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFydGlmYWN0LmRlcGVuZGVuY2llcyA9IGRlcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuY29sbGVjdE1ldGFkYXRhKCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKG1ldGEpLmxlbmd0aCA+IDApIHtcbiAgICAgIGFydGlmYWN0Lm1ldGFkYXRhID0gbWV0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taXNzaW5nQ29udGV4dCAmJiBPYmplY3Qua2V5cyh0aGlzLm1pc3NpbmdDb250ZXh0KS5sZW5ndGggPiAwKSB7XG4gICAgICBhcnRpZmFjdC5taXNzaW5nID0gdGhpcy5taXNzaW5nQ29udGV4dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgYW4gYXJ0aWZhY3QgdGhhdCByZXByZXNlbnRzIHRoaXMgc3RhY2tcbiAgICBzZXNzaW9uLmFkZEFydGlmYWN0KHRoaXMubm9kZS5pZCwgYXJ0aWZhY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZWQgZGVmYXVsdHMgdG8gZW52aXJvbm1lbnQgYXR0cmlidXRlcy5cbiAgICovXG4gIHByaXZhdGUgcGFyc2VFbnZpcm9ubWVudChwcm9wcz86IFN0YWNrUHJvcHMpIHtcbiAgICAvLyBzdGFydCB3aXRoIGBlbnZgLlxuICAgIGNvbnN0IGVudjogRW52aXJvbm1lbnQgPSAocHJvcHMgJiYgcHJvcHMuZW52KSB8fCB7IH07XG5cbiAgICAvLyBpZiBhY2NvdW50IGlzIG5vdCBzcGVjaWZpZWQsIGF0dGVtcHQgdG8gcmVhZCBmcm9tIGNvbnRleHQuXG4gICAgaWYgKCFlbnYuYWNjb3VudCkge1xuICAgICAgZW52LmFjY291bnQgPSB0aGlzLm5vZGUuZ2V0Q29udGV4dChjeGFwaS5ERUZBVUxUX0FDQ09VTlRfQ09OVEVYVF9LRVkpO1xuICAgIH1cblxuICAgIC8vIGlmIHJlZ2lvbiBpcyBub3Qgc3BlY2lmaWVkLCBhdHRlbXB0IHRvIHJlYWQgZnJvbSBjb250ZXh0LlxuICAgIGlmICghZW52LnJlZ2lvbikge1xuICAgICAgZW52LnJlZ2lvbiA9IHRoaXMubm9kZS5nZXRDb250ZXh0KGN4YXBpLkRFRkFVTFRfUkVHSU9OX0NPTlRFWFRfS0VZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW52O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBzdGFjayBoYXMgYSAodHJhbnNpdGl2ZSkgZGVwZW5kZW5jeSBvbiBhbm90aGVyIHN0YWNrXG4gICAqL1xuICBwcml2YXRlIGRlcGVuZHNPblN0YWNrKG90aGVyOiBTdGFjaykge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGZvciAoY29uc3QgZGVwIG9mIHRoaXMuc3RhY2tEZXBlbmRlbmNpZXMpIHtcbiAgICAgIGlmIChkZXAuZGVwZW5kc09uU3RhY2sob3RoZXIpKSB7IHJldHVybiB0cnVlOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgY29sbGVjdE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG91dHB1dDogeyBbaWQ6IHN0cmluZ106IGN4YXBpLk1ldGFkYXRhRW50cnlbXSB9ID0geyB9O1xuXG4gICAgdmlzaXQodGhpcyk7XG5cbiAgICBjb25zdCBhcHAgPSB0aGlzLnBhcmVudEFwcCgpO1xuICAgIGlmIChhcHAgJiYgYXBwLm5vZGUubWV0YWRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgb3V0cHV0W1BBVEhfU0VQXSA9IGFwcC5ub2RlLm1ldGFkYXRhO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICBmdW5jdGlvbiB2aXNpdChub2RlOiBJQ29uc3RydWN0KSB7XG4gICAgICBpZiAobm9kZS5ub2RlLm1ldGFkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgcGF0aCBhYnNvbHV0ZVxuICAgICAgICBvdXRwdXRbUEFUSF9TRVAgKyBub2RlLm5vZGUucGF0aF0gPSBub2RlLm5vZGUubWV0YWRhdGEubWFwKG1kID0+IG5vZGUubm9kZS5yZXNvbHZlKG1kKSBhcyBjeGFwaS5NZXRhZGF0YUVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdmlzaXQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZSh0ZW1wbGF0ZTogYW55LCBwYXJ0OiBhbnkpIHtcbiAgZm9yIChjb25zdCBzZWN0aW9uIG9mIE9iamVjdC5rZXlzKHBhcnQpKSB7XG4gICAgY29uc3Qgc3JjID0gcGFydFtzZWN0aW9uXTtcblxuICAgIC8vIGNyZWF0ZSB0b3AtbGV2ZWwgc2VjdGlvbiBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgbGV0IGRlc3QgPSB0ZW1wbGF0ZVtzZWN0aW9uXTtcbiAgICBpZiAoIWRlc3QpIHtcbiAgICAgIHRlbXBsYXRlW3NlY3Rpb25dID0gZGVzdCA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWRkIGFsbCBlbnRpdGllcyBmcm9tIHNvdXJjZSBzZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHNlY3Rpb25cbiAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMoc3JjKSkge1xuICAgICAgICBpZiAoaWQgaW4gZGVzdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2VjdGlvbiAnJHtzZWN0aW9ufScgYWxyZWFkeSBjb250YWlucyAnJHtpZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFtpZF0gPSBzcmNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIG9wdGlvbnMgZm9yIGEgc3RhY2suXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgZGVzY3JpcHRpb24gb2YgdGhpcyBzdGFjay5cbiAgICogSWYgcHJvdmlkZWQsIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlJ3MgXCJEZXNjcmlwdGlvblwiIGF0dHJpYnV0ZS5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIEFXU1RlbXBsYXRlRm9ybWF0VmVyc2lvbiBmaWVsZCBvZiB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUuXG4gICAqL1xuICB0ZW1wbGF0ZUZvcm1hdFZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgdG9wLWxldmVsIHRlbXBsYXRlIHRyYW5zZm9ybSBmb3IgdGhpcyBzdGFjayAoZS5nLiBcIkFXUzo6U2VydmVybGVzcy0yMDE2LTEwLTMxXCIpLlxuICAgKi9cbiAgdHJhbnNmb3JtPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLlxuICAgKi9cbiAgIG1ldGFkYXRhPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGFsbCBTdGFja0VsZW1lbnRzIGZyb20gYSBjb25zdHJ1Y3RcbiAqXG4gKiBAcGFyYW0gbm9kZSBSb290IG5vZGUgdG8gY29sbGVjdCBhbGwgU3RhY2tFbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0gaW50byBBcnJheSB0byBhcHBlbmQgU3RhY2tFbGVtZW50cyB0b1xuICogQHJldHVybnMgVGhlIHNhbWUgYXJyYXkgYXMgaXMgYmVpbmcgY29sbGVjdGVkIGludG9cbiAqL1xuZnVuY3Rpb24gc3RhY2tFbGVtZW50cyhub2RlOiBJQ29uc3RydWN0LCBpbnRvOiBTdGFja0VsZW1lbnRbXSA9IFtdKTogU3RhY2tFbGVtZW50W10ge1xuICBpZiAoU3RhY2tFbGVtZW50LmlzU3RhY2tFbGVtZW50KG5vZGUpKSB7XG4gICAgaW50by5wdXNoKG5vZGUpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLm5vZGUuY2hpbGRyZW4pIHtcbiAgICBzdGFja0VsZW1lbnRzKGNoaWxkLCBpbnRvKTtcbiAgfVxuXG4gIHJldHVybiBpbnRvO1xufVxuXG4vLyBUaGVzZSBpbXBvcnRzIGhhdmUgdG8gYmUgYXQgdGhlIGVuZCB0byBwcmV2ZW50IGNpcmN1bGFyIGltcG9ydHNcbmltcG9ydCB7IEFybkNvbXBvbmVudHMsIGFybkZyb21Db21wb25lbnRzLCBwYXJzZUFybiB9IGZyb20gJy4vYXJuJztcbmltcG9ydCB7IEF3cywgU2NvcGVkQXdzIH0gZnJvbSAnLi9wc2V1ZG8nO1xuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL3Jlc291cmNlJztcbmltcG9ydCB7IFN0YWNrRWxlbWVudCB9IGZyb20gJy4vc3RhY2stZWxlbWVudCc7XG5cbi8qKlxuICogRmluZCBhbGwgcmVzb3VyY2VzIGluIGEgc2V0IG9mIGNvbnN0cnVjdHNcbiAqL1xuZnVuY3Rpb24gZmluZFJlc291cmNlcyhyb290czogSXRlcmFibGU8SUNvbnN0cnVjdD4pOiBSZXNvdXJjZVtdIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PFJlc291cmNlPigpO1xuICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMpIHtcbiAgICByZXQucHVzaCguLi5yb290Lm5vZGUuZmluZEFsbCgpLmZpbHRlcihSZXNvdXJjZS5pc1Jlc291cmNlKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==