"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tokens_1 = require("../core/tokens");
/**
 * A Token that represents a CloudFormation reference to another resource
 *
 * If these references are used in a different stack from where they are
 * defined, appropriate CloudFormation `Export`s and `Fn::ImportValue`s will be
 * synthesized automatically instead of the regular CloudFormation references.
 *
 * Additionally, the dependency between the stacks will be recorded, and the toolkit
 * will make sure to deploy producing stack before the consuming stack.
 *
 * This magic happens in the prepare() phase, where consuming stacks will call
 * `consumeFromStack` on these Tokens and if they happen to be exported by a different
 * Stack, we'll register the dependency.
 */
class CfnReference extends tokens_1.Token {
    /**
     * Check whether this is actually a CfnReference
     */
    static isCfnReference(x) {
        return x.consumeFromStack !== undefined;
    }
    constructor(value, displayName, scope) {
        if (typeof (value) === 'function') {
            throw new Error('CfnReference can only hold CloudFormation intrinsics (not a function)');
        }
        // prepend scope path to display name
        if (displayName && scope) {
            displayName = `${scope.node.path}.${displayName}`;
        }
        super(value, displayName);
        this.replacementTokens = new Map();
        this.isReference = true;
        if (scope !== undefined) {
            this.producingStack = scope.node.stack;
        }
    }
    resolve(context) {
        // If we have a special token for this consuming stack, resolve that. Otherwise resolve as if
        // we are in the same stack.
        const token = this.replacementTokens.get(context.scope.node.stack);
        if (token) {
            return token.resolve(context);
        }
        else {
            return super.resolve(context);
        }
    }
    /**
     * Register a stack this references is being consumed from.
     */
    consumeFromStack(consumingStack) {
        if (this.producingStack && this.producingStack !== consumingStack && !this.replacementTokens.has(consumingStack)) {
            // We're trying to resolve a cross-stack reference
            consumingStack.addDependency(this.producingStack);
            this.replacementTokens.set(consumingStack, this.exportValue(this, consumingStack));
        }
    }
    /**
     * Export a Token value for use in another stack
     *
     * Works by mutating the producing stack in-place.
     */
    exportValue(tokenValue, consumingStack) {
        const producingStack = this.producingStack;
        if (producingStack.env.account !== consumingStack.env.account || producingStack.env.region !== consumingStack.env.region) {
            throw new Error('Can only reference cross stacks in the same region and account.');
        }
        // Ensure a singleton "Exports" scoping Construct
        // This mostly exists to trigger LogicalID munging, which would be
        // disabled if we parented constructs directly under Stack.
        // Also it nicely prevents likely construct name clashes
        const exportsName = 'Exports';
        let stackExports = producingStack.node.tryFindChild(exportsName);
        if (stackExports === undefined) {
            stackExports = new construct_1.Construct(producingStack, exportsName);
        }
        // Ensure a singleton Output for this value
        const resolved = producingStack.node.resolve(tokenValue);
        const id = 'Output' + JSON.stringify(resolved);
        let output = stackExports.node.tryFindChild(id);
        if (!output) {
            output = new output_1.Output(stackExports, id, { value: tokenValue });
        }
        // We want to return an actual FnImportValue Token here, but Fn.importValue() returns a 'string',
        // so construct one in-place.
        return new tokens_1.Token({ 'Fn::ImportValue': output.obtainExportName() });
    }
}
exports.CfnReference = CfnReference;
const construct_1 = require("../core/construct");
const output_1 = require("./output");
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2ZuLXRva2Vucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNmbi10b2tlbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQ0FBdUQ7QUFFdkQ7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNILE1BQWEsWUFBYSxTQUFRLGNBQUs7SUFDckM7O09BRUc7SUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQVE7UUFDbkMsT0FBUSxDQUFTLENBQUMsZ0JBQWdCLEtBQUssU0FBUyxDQUFDO0lBQ25ELENBQUM7SUFjRCxZQUFZLEtBQVUsRUFBRSxXQUFvQixFQUFFLEtBQWlCO1FBQzdELElBQUksT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLHVFQUF1RSxDQUFDLENBQUM7U0FDNUY7UUFDRCxxQ0FBcUM7UUFDckMsSUFBSSxXQUFXLElBQUksS0FBSyxFQUFFO1lBQ3hCLFdBQVcsR0FBRyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLFdBQVcsRUFBRSxDQUFDO1NBQ25EO1FBQ0QsS0FBSyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxHQUFHLEVBQWdCLENBQUM7UUFDakQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFFeEIsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDeEM7SUFDSCxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXVCO1FBQ3BDLDZGQUE2RjtRQUM3Riw0QkFBNEI7UUFDNUIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuRSxJQUFJLEtBQUssRUFBRTtZQUNULE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMvQjthQUFNO1lBQ0wsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQy9CO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZ0JBQWdCLENBQUMsY0FBcUI7UUFDM0MsSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssY0FBYyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUNoSCxrREFBa0Q7WUFDbEQsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztTQUNwRjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssV0FBVyxDQUFDLFVBQWlCLEVBQUUsY0FBcUI7UUFDMUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWUsQ0FBQztRQUU1QyxJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsT0FBTyxLQUFLLGNBQWMsQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFO1lBQ3hILE1BQU0sSUFBSSxLQUFLLENBQUMsaUVBQWlFLENBQUMsQ0FBQztTQUNwRjtRQUVELGlEQUFpRDtRQUNqRCxrRUFBa0U7UUFDbEUsMkRBQTJEO1FBQzNELHdEQUF3RDtRQUV4RCxNQUFNLFdBQVcsR0FBRyxTQUFTLENBQUM7UUFDOUIsSUFBSSxZQUFZLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFjLENBQUM7UUFDOUUsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO1lBQzlCLFlBQVksR0FBRyxJQUFJLHFCQUFTLENBQUMsY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1NBQzNEO1FBRUQsMkNBQTJDO1FBQzNDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sRUFBRSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLElBQUksTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBVyxDQUFDO1FBQzFELElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsWUFBWSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQzlEO1FBRUQsaUdBQWlHO1FBQ2pHLDZCQUE2QjtRQUM3QixPQUFPLElBQUksY0FBSyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7Q0FFRjtBQS9GRCxvQ0ErRkM7QUFFRCxpREFBOEM7QUFDOUMscUNBQWtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzb2x2ZUNvbnRleHQsIFRva2VuIH0gZnJvbSBcIi4uL2NvcmUvdG9rZW5zXCI7XG5cbi8qKlxuICogQSBUb2tlbiB0aGF0IHJlcHJlc2VudHMgYSBDbG91ZEZvcm1hdGlvbiByZWZlcmVuY2UgdG8gYW5vdGhlciByZXNvdXJjZVxuICpcbiAqIElmIHRoZXNlIHJlZmVyZW5jZXMgYXJlIHVzZWQgaW4gYSBkaWZmZXJlbnQgc3RhY2sgZnJvbSB3aGVyZSB0aGV5IGFyZVxuICogZGVmaW5lZCwgYXBwcm9wcmlhdGUgQ2xvdWRGb3JtYXRpb24gYEV4cG9ydGBzIGFuZCBgRm46OkltcG9ydFZhbHVlYHMgd2lsbCBiZVxuICogc3ludGhlc2l6ZWQgYXV0b21hdGljYWxseSBpbnN0ZWFkIG9mIHRoZSByZWd1bGFyIENsb3VkRm9ybWF0aW9uIHJlZmVyZW5jZXMuXG4gKlxuICogQWRkaXRpb25hbGx5LCB0aGUgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSBzdGFja3Mgd2lsbCBiZSByZWNvcmRlZCwgYW5kIHRoZSB0b29sa2l0XG4gKiB3aWxsIG1ha2Ugc3VyZSB0byBkZXBsb3kgcHJvZHVjaW5nIHN0YWNrIGJlZm9yZSB0aGUgY29uc3VtaW5nIHN0YWNrLlxuICpcbiAqIFRoaXMgbWFnaWMgaGFwcGVucyBpbiB0aGUgcHJlcGFyZSgpIHBoYXNlLCB3aGVyZSBjb25zdW1pbmcgc3RhY2tzIHdpbGwgY2FsbFxuICogYGNvbnN1bWVGcm9tU3RhY2tgIG9uIHRoZXNlIFRva2VucyBhbmQgaWYgdGhleSBoYXBwZW4gdG8gYmUgZXhwb3J0ZWQgYnkgYSBkaWZmZXJlbnRcbiAqIFN0YWNrLCB3ZSdsbCByZWdpc3RlciB0aGUgZGVwZW5kZW5jeS5cbiAqL1xuZXhwb3J0IGNsYXNzIENmblJlZmVyZW5jZSBleHRlbmRzIFRva2VuIHtcbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSBhIENmblJlZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc0NmblJlZmVyZW5jZSh4OiBUb2tlbik6IHggaXMgQ2ZuUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gKHggYXMgYW55KS5jb25zdW1lRnJvbVN0YWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgcmVhZG9ubHkgaXNSZWZlcmVuY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGF0IHN0YWNrIHRoaXMgVG9rZW4gaXMgcG9pbnRpbmcgdG9cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvZHVjaW5nU3RhY2s/OiBTdGFjaztcblxuICAvKipcbiAgICogVGhlIFRva2VucyB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCBmb3IgZWFjaCBjb25zdW1pbmcgc3RhY2sgKGFzIGRlY2lkZWQgYnkgdGhlIHByb2R1Y2luZyBTdGFjaylcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVwbGFjZW1lbnRUb2tlbnM6IE1hcDxTdGFjaywgVG9rZW4+O1xuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBhbnksIGRpc3BsYXlOYW1lPzogc3RyaW5nLCBzY29wZT86IENvbnN0cnVjdCkge1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2ZuUmVmZXJlbmNlIGNhbiBvbmx5IGhvbGQgQ2xvdWRGb3JtYXRpb24gaW50cmluc2ljcyAobm90IGEgZnVuY3Rpb24pJyk7XG4gICAgfVxuICAgIC8vIHByZXBlbmQgc2NvcGUgcGF0aCB0byBkaXNwbGF5IG5hbWVcbiAgICBpZiAoZGlzcGxheU5hbWUgJiYgc2NvcGUpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gYCR7c2NvcGUubm9kZS5wYXRofS4ke2Rpc3BsYXlOYW1lfWA7XG4gICAgfVxuICAgIHN1cGVyKHZhbHVlLCBkaXNwbGF5TmFtZSk7XG4gICAgdGhpcy5yZXBsYWNlbWVudFRva2VucyA9IG5ldyBNYXA8U3RhY2ssIFRva2VuPigpO1xuICAgIHRoaXMuaXNSZWZlcmVuY2UgPSB0cnVlO1xuXG4gICAgaWYgKHNjb3BlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucHJvZHVjaW5nU3RhY2sgPSBzY29wZS5ub2RlLnN0YWNrO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKGNvbnRleHQ6IFJlc29sdmVDb250ZXh0KTogYW55IHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgc3BlY2lhbCB0b2tlbiBmb3IgdGhpcyBjb25zdW1pbmcgc3RhY2ssIHJlc29sdmUgdGhhdC4gT3RoZXJ3aXNlIHJlc29sdmUgYXMgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGhlIHNhbWUgc3RhY2suXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnJlcGxhY2VtZW50VG9rZW5zLmdldChjb250ZXh0LnNjb3BlLm5vZGUuc3RhY2spO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnJlc29sdmUoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXNvbHZlKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHN0YWNrIHRoaXMgcmVmZXJlbmNlcyBpcyBiZWluZyBjb25zdW1lZCBmcm9tLlxuICAgKi9cbiAgcHVibGljIGNvbnN1bWVGcm9tU3RhY2soY29uc3VtaW5nU3RhY2s6IFN0YWNrKSB7XG4gICAgaWYgKHRoaXMucHJvZHVjaW5nU3RhY2sgJiYgdGhpcy5wcm9kdWNpbmdTdGFjayAhPT0gY29uc3VtaW5nU3RhY2sgJiYgIXRoaXMucmVwbGFjZW1lbnRUb2tlbnMuaGFzKGNvbnN1bWluZ1N0YWNrKSkge1xuICAgICAgLy8gV2UncmUgdHJ5aW5nIHRvIHJlc29sdmUgYSBjcm9zcy1zdGFjayByZWZlcmVuY2VcbiAgICAgIGNvbnN1bWluZ1N0YWNrLmFkZERlcGVuZGVuY3kodGhpcy5wcm9kdWNpbmdTdGFjayk7XG4gICAgICB0aGlzLnJlcGxhY2VtZW50VG9rZW5zLnNldChjb25zdW1pbmdTdGFjaywgdGhpcy5leHBvcnRWYWx1ZSh0aGlzLCBjb25zdW1pbmdTdGFjaykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgYSBUb2tlbiB2YWx1ZSBmb3IgdXNlIGluIGFub3RoZXIgc3RhY2tcbiAgICpcbiAgICogV29ya3MgYnkgbXV0YXRpbmcgdGhlIHByb2R1Y2luZyBzdGFjayBpbi1wbGFjZS5cbiAgICovXG4gIHByaXZhdGUgZXhwb3J0VmFsdWUodG9rZW5WYWx1ZTogVG9rZW4sIGNvbnN1bWluZ1N0YWNrOiBTdGFjayk6IFRva2VuIHtcbiAgICBjb25zdCBwcm9kdWNpbmdTdGFjayA9IHRoaXMucHJvZHVjaW5nU3RhY2shO1xuXG4gICAgaWYgKHByb2R1Y2luZ1N0YWNrLmVudi5hY2NvdW50ICE9PSBjb25zdW1pbmdTdGFjay5lbnYuYWNjb3VudCB8fCBwcm9kdWNpbmdTdGFjay5lbnYucmVnaW9uICE9PSBjb25zdW1pbmdTdGFjay5lbnYucmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHJlZmVyZW5jZSBjcm9zcyBzdGFja3MgaW4gdGhlIHNhbWUgcmVnaW9uIGFuZCBhY2NvdW50LicpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhIHNpbmdsZXRvbiBcIkV4cG9ydHNcIiBzY29waW5nIENvbnN0cnVjdFxuICAgIC8vIFRoaXMgbW9zdGx5IGV4aXN0cyB0byB0cmlnZ2VyIExvZ2ljYWxJRCBtdW5naW5nLCB3aGljaCB3b3VsZCBiZVxuICAgIC8vIGRpc2FibGVkIGlmIHdlIHBhcmVudGVkIGNvbnN0cnVjdHMgZGlyZWN0bHkgdW5kZXIgU3RhY2suXG4gICAgLy8gQWxzbyBpdCBuaWNlbHkgcHJldmVudHMgbGlrZWx5IGNvbnN0cnVjdCBuYW1lIGNsYXNoZXNcblxuICAgIGNvbnN0IGV4cG9ydHNOYW1lID0gJ0V4cG9ydHMnO1xuICAgIGxldCBzdGFja0V4cG9ydHMgPSBwcm9kdWNpbmdTdGFjay5ub2RlLnRyeUZpbmRDaGlsZChleHBvcnRzTmFtZSkgYXMgQ29uc3RydWN0O1xuICAgIGlmIChzdGFja0V4cG9ydHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhY2tFeHBvcnRzID0gbmV3IENvbnN0cnVjdChwcm9kdWNpbmdTdGFjaywgZXhwb3J0c05hbWUpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhIHNpbmdsZXRvbiBPdXRwdXQgZm9yIHRoaXMgdmFsdWVcbiAgICBjb25zdCByZXNvbHZlZCA9IHByb2R1Y2luZ1N0YWNrLm5vZGUucmVzb2x2ZSh0b2tlblZhbHVlKTtcbiAgICBjb25zdCBpZCA9ICdPdXRwdXQnICsgSlNPTi5zdHJpbmdpZnkocmVzb2x2ZWQpO1xuICAgIGxldCBvdXRwdXQgPSBzdGFja0V4cG9ydHMubm9kZS50cnlGaW5kQ2hpbGQoaWQpIGFzIE91dHB1dDtcbiAgICBpZiAoIW91dHB1dCkge1xuICAgICAgb3V0cHV0ID0gbmV3IE91dHB1dChzdGFja0V4cG9ydHMsIGlkLCB7IHZhbHVlOiB0b2tlblZhbHVlIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIHdhbnQgdG8gcmV0dXJuIGFuIGFjdHVhbCBGbkltcG9ydFZhbHVlIFRva2VuIGhlcmUsIGJ1dCBGbi5pbXBvcnRWYWx1ZSgpIHJldHVybnMgYSAnc3RyaW5nJyxcbiAgICAvLyBzbyBjb25zdHJ1Y3Qgb25lIGluLXBsYWNlLlxuICAgIHJldHVybiBuZXcgVG9rZW4oeyAnRm46OkltcG9ydFZhbHVlJzogb3V0cHV0Lm9idGFpbkV4cG9ydE5hbWUoKSB9KTtcbiAgfVxuXG59XG5cbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCIuLi9jb3JlL2NvbnN0cnVjdFwiO1xuaW1wb3J0IHsgT3V0cHV0IH0gZnJvbSBcIi4vb3V0cHV0XCI7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gXCIuL3N0YWNrXCI7XG4iXX0=