"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const construct_1 = require("../core/construct");
const tokens_1 = require("../core/tokens");
/**
 * References a dynamically retrieved value
 *
 * This is a Construct so that subclasses will (eventually) be able to attach
 * metadata to themselves without having to change call signatures.
 *
 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html
 */
class DynamicReference extends construct_1.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        this._value = this.makeResolveValue(props.service, props.referenceKey);
    }
    /**
     * The value of this dynamic reference
     */
    get stringValue() {
        return this._value;
    }
    /**
     * Make a dynamic reference Token value
     *
     * This is a value (similar to CDK Tokens) that will be substituted by
     * CloudFormation before executing the changeset.
     */
    makeResolveValue(service, referenceKey) {
        const resolveString = '{{resolve:' + service + ':' + referenceKey + '}}';
        // We don't strictly need to Tokenize a string here, but we do it anyway to be perfectly
        // clear that DynamicReference.value is unparseable in CDK apps.
        return new tokens_1.Token(resolveString).toString();
    }
}
exports.DynamicReference = DynamicReference;
/**
 * The service to retrieve the dynamic reference from
 */
var DynamicReferenceService;
(function (DynamicReferenceService) {
    /**
     * Plaintext value stored in AWS Systems Manager Parameter Store
     */
    DynamicReferenceService["Ssm"] = "ssm";
    /**
     * Secure string stored in AWS Systems Manager Parameter Store
     */
    DynamicReferenceService["SsmSecure"] = "ssm-secure";
    /**
     * Secret stored in AWS Secrets Manager
     */
    DynamicReferenceService["SecretsManager"] = "secretsmanager";
})(DynamicReferenceService = exports.DynamicReferenceService || (exports.DynamicReferenceService = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1yZWZlcmVuY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeW5hbWljLXJlZmVyZW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlEQUE4QztBQUM5QywyQ0FBdUM7QUFpQnZDOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLGdCQUFpQixTQUFRLHFCQUFTO0lBRzdDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBNEI7UUFDcEUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVqQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLFdBQVc7UUFDcEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLGdCQUFnQixDQUFDLE9BQWdDLEVBQUUsWUFBb0I7UUFDL0UsTUFBTSxhQUFhLEdBQUcsWUFBWSxHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsWUFBWSxHQUFHLElBQUksQ0FBQztRQUV6RSx3RkFBd0Y7UUFDeEYsZ0VBQWdFO1FBQ2hFLE9BQU8sSUFBSSxjQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDN0MsQ0FBQztDQUNGO0FBN0JELDRDQTZCQztBQUVEOztHQUVHO0FBQ0gsSUFBWSx1QkFlWDtBQWZELFdBQVksdUJBQXVCO0lBQ2pDOztPQUVHO0lBQ0gsc0NBQVcsQ0FBQTtJQUVYOztPQUVHO0lBQ0gsbURBQXdCLENBQUE7SUFFeEI7O09BRUc7SUFDSCw0REFBaUMsQ0FBQTtBQUNuQyxDQUFDLEVBZlcsdUJBQXVCLEdBQXZCLCtCQUF1QixLQUF2QiwrQkFBdUIsUUFlbEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiLi4vY29yZS9jb25zdHJ1Y3RcIjtcbmltcG9ydCB7IFRva2VuIH0gZnJvbSBcIi4uL2NvcmUvdG9rZW5zXCI7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYSBEeW5hbWljIFJlZmVyZW5jZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIER5bmFtaWNSZWZlcmVuY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgc2VydmljZSB0byByZXRyaWV2ZSB0aGUgZHluYW1pYyByZWZlcmVuY2UgZnJvbVxuICAgKi9cbiAgc2VydmljZTogRHluYW1pY1JlZmVyZW5jZVNlcnZpY2U7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2Uga2V5IG9mIHRoZSBkeW5hbWljIHJlZmVyZW5jZVxuICAgKi9cbiAgcmVmZXJlbmNlS2V5OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhIGR5bmFtaWNhbGx5IHJldHJpZXZlZCB2YWx1ZVxuICpcbiAqIFRoaXMgaXMgYSBDb25zdHJ1Y3Qgc28gdGhhdCBzdWJjbGFzc2VzIHdpbGwgKGV2ZW50dWFsbHkpIGJlIGFibGUgdG8gYXR0YWNoXG4gKiBtZXRhZGF0YSB0byB0aGVtc2VsdmVzIHdpdGhvdXQgaGF2aW5nIHRvIGNoYW5nZSBjYWxsIHNpZ25hdHVyZXMuXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS9keW5hbWljLXJlZmVyZW5jZXMuaHRtbFxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY1JlZmVyZW5jZSBleHRlbmRzIENvbnN0cnVjdCB7XG4gIHByaXZhdGUgX3ZhbHVlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IER5bmFtaWNSZWZlcmVuY2VQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMubWFrZVJlc29sdmVWYWx1ZShwcm9wcy5zZXJ2aWNlLCBwcm9wcy5yZWZlcmVuY2VLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGlzIGR5bmFtaWMgcmVmZXJlbmNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0cmluZ1ZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBkeW5hbWljIHJlZmVyZW5jZSBUb2tlbiB2YWx1ZVxuICAgKlxuICAgKiBUaGlzIGlzIGEgdmFsdWUgKHNpbWlsYXIgdG8gQ0RLIFRva2VucykgdGhhdCB3aWxsIGJlIHN1YnN0aXR1dGVkIGJ5XG4gICAqIENsb3VkRm9ybWF0aW9uIGJlZm9yZSBleGVjdXRpbmcgdGhlIGNoYW5nZXNldC5cbiAgICovXG4gIHByb3RlY3RlZCBtYWtlUmVzb2x2ZVZhbHVlKHNlcnZpY2U6IER5bmFtaWNSZWZlcmVuY2VTZXJ2aWNlLCByZWZlcmVuY2VLZXk6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc29sdmVTdHJpbmcgPSAne3tyZXNvbHZlOicgKyBzZXJ2aWNlICsgJzonICsgcmVmZXJlbmNlS2V5ICsgJ319JztcblxuICAgIC8vIFdlIGRvbid0IHN0cmljdGx5IG5lZWQgdG8gVG9rZW5pemUgYSBzdHJpbmcgaGVyZSwgYnV0IHdlIGRvIGl0IGFueXdheSB0byBiZSBwZXJmZWN0bHlcbiAgICAvLyBjbGVhciB0aGF0IER5bmFtaWNSZWZlcmVuY2UudmFsdWUgaXMgdW5wYXJzZWFibGUgaW4gQ0RLIGFwcHMuXG4gICAgcmV0dXJuIG5ldyBUb2tlbihyZXNvbHZlU3RyaW5nKS50b1N0cmluZygpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHNlcnZpY2UgdG8gcmV0cmlldmUgdGhlIGR5bmFtaWMgcmVmZXJlbmNlIGZyb21cbiAqL1xuZXhwb3J0IGVudW0gRHluYW1pY1JlZmVyZW5jZVNlcnZpY2Uge1xuICAvKipcbiAgICogUGxhaW50ZXh0IHZhbHVlIHN0b3JlZCBpbiBBV1MgU3lzdGVtcyBNYW5hZ2VyIFBhcmFtZXRlciBTdG9yZVxuICAgKi9cbiAgU3NtID0gJ3NzbScsXG5cbiAgLyoqXG4gICAqIFNlY3VyZSBzdHJpbmcgc3RvcmVkIGluIEFXUyBTeXN0ZW1zIE1hbmFnZXIgUGFyYW1ldGVyIFN0b3JlXG4gICAqL1xuICBTc21TZWN1cmUgPSAnc3NtLXNlY3VyZScsXG5cbiAgLyoqXG4gICAqIFNlY3JldCBzdG9yZWQgaW4gQVdTIFNlY3JldHMgTWFuYWdlclxuICAgKi9cbiAgU2VjcmV0c01hbmFnZXIgPSAnc2VjcmV0c21hbmFnZXInLFxufVxuIl19