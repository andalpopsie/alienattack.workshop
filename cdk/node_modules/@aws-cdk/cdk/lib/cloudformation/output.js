"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const construct_1 = require("../core/construct");
const stack_element_1 = require("./stack-element");
class Output extends stack_element_1.StackElement {
    /**
     * Creates an Output value for this stack.
     * @param parent The parent construct.
     * @param props Output properties.
     */
    constructor(scope, id, props = {}) {
        super(scope, id);
        this.description = props.description;
        this._value = props.value;
        this.condition = props.condition;
        this.disableExport = props.disableExport !== undefined ? props.disableExport : false;
        if (props.export && this.disableExport) {
            throw new Error('Cannot set `disableExport` and specify an export name');
        }
        this.export = props.export;
        if (props.export) {
            this.export = props.export;
        }
    }
    /**
     * The value of the property returned by the aws cloudformation describe-stacks command.
     * The value of an output can include literals, parameter references, pseudo-parameters,
     * a mapping value, or intrinsic functions.
     */
    get value() {
        return this._value;
    }
    /**
     * Returns an FnImportValue bound to this export name.
     */
    makeImportValue() {
        return fn().importValue(this.obtainExportName());
    }
    toCloudFormation() {
        return {
            Outputs: {
                [this.logicalId]: {
                    Description: this.description,
                    Value: this.value,
                    Export: this.export != null ? { Name: this.export } : undefined,
                    Condition: this.condition ? this.condition.logicalId : undefined
                }
            }
        };
    }
    get ref() {
        throw new Error('Outputs cannot be referenced');
    }
    /**
     * Allocate an export name for this `Output` if not already done.
     */
    obtainExportName() {
        if (!this.export && this.disableExport) {
            throw new Error('Cannot create an ImportValue; `disableExport` has been set.');
        }
        if (!this.export) {
            this.export = this.uniqueOutputName();
        }
        return this.export;
    }
    /**
     * Automatically determine an output name for use with FnImportValue
     *
     * This gets called in case the user hasn't specified an export name but is
     * taking an action that requires exporting. We namespace with the stack name
     * to reduce chances of collissions between CDK apps.
     */
    uniqueOutputName() {
        // prefix export name with stack name since exports are global within account + region.
        const stackName = this.node.stack.name;
        return (stackName ? stackName + ':' : '') + this.logicalId;
    }
}
exports.Output = Output;
/**
 * An output for a list of strings.
 *
 * Exports a list of Tokens via an Output variable, and return a list of Tokens
 * that selects the imported values for them.
 */
class StringListOutput extends construct_1.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        this.separator = props.separator || ',';
        this.length = props.values.length;
        this.output = new Output(this, 'Resource', {
            description: props.description,
            condition: props.condition,
            disableExport: props.disableExport,
            export: props.export,
            value: fn().join(this.separator, props.values)
        });
    }
    /**
     * Return an array of imported values for this Output
     */
    makeImportValues() {
        const combined = this.output.makeImportValue();
        const ret = [];
        for (let i = 0; i < this.length; i++) {
            ret.push(fn().select(i, fn().split(this.separator, combined)));
        }
        return ret;
    }
}
exports.StringListOutput = StringListOutput;
function fn() {
    // Lazy loading of "Fn" module to break dependency cycles on startup
    return require('./fn').Fn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0cHV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3V0cHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaURBQThDO0FBQzlDLG1EQUErQztBQTZDL0MsTUFBYSxNQUFPLFNBQVEsNEJBQVk7SUEwQnRDOzs7O09BSUc7SUFDSCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLFFBQXFCLEVBQUU7UUFDL0QsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVqQixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7UUFDckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQzFCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUVqQyxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxhQUFhLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFFckYsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1NBQzFFO1FBRUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1FBRTNCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNoQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7U0FDNUI7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsS0FBSztRQUNkLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxlQUFlO1FBQ3BCLE9BQU8sRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJ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QUFHLENBQUM7SUFDYixDQUFDO0NBQ0Y7QUE1Q0QsNENBNENDO0FBRUQsU0FBUyxFQUFFO0lBQ1Qsb0VBQW9FO0lBQ3BFLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUM1QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnLi4vY29yZS9jb25zdHJ1Y3QnO1xuaW1wb3J0IHsgU3RhY2tFbGVtZW50IH0gZnJvbSAnLi9zdGFjay1lbGVtZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBPdXRwdXRQcm9wcyB7XG4gIC8qKlxuICAgKiBBIFN0cmluZyB0eXBlIHRoYXQgZGVzY3JpYmVzIHRoZSBvdXRwdXQgdmFsdWUuXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBjYW4gYmUgYSBtYXhpbXVtIG9mIDQgSyBpbiBsZW5ndGguXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSByZXR1cm5lZCBieSB0aGUgYXdzIGNsb3VkZm9ybWF0aW9uIGRlc2NyaWJlLXN0YWNrcyBjb21tYW5kLlxuICAgKiBUaGUgdmFsdWUgb2YgYW4gb3V0cHV0IGNhbiBpbmNsdWRlIGxpdGVyYWxzLCBwYXJhbWV0ZXIgcmVmZXJlbmNlcywgcHNldWRvLXBhcmFtZXRlcnMsXG4gICAqIGEgbWFwcGluZyB2YWx1ZSwgb3IgaW50cmluc2ljIGZ1bmN0aW9ucy5cbiAgICovXG4gIHZhbHVlPzogYW55O1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSB1c2VkIHRvIGV4cG9ydCB0aGUgdmFsdWUgb2YgdGhpcyBvdXRwdXQgYWNyb3NzIHN0YWNrcy5cbiAgICpcbiAgICogVG8gaW1wb3J0IHRoZSB2YWx1ZSBmcm9tIGFub3RoZXIgc3RhY2ssIHVzZSBgRm5JbXBvcnRWYWx1ZShleHBvcnQpYC4gWW91XG4gICAqIGNhbiBjcmVhdGUgYW4gaW1wb3J0IHZhbHVlIHRva2VuIGJ5IGNhbGxpbmcgYG91dHB1dC5tYWtlSW1wb3J0VmFsdWUoKWAuXG4gICAqXG4gICAqIEBkZWZhdWx0IEF1dG9tYXRpY2FsbHkgYWxsb2NhdGUgYSBuYW1lIHdoZW4gYG1ha2VJbXBvcnRWYWx1ZSgpYCAgaXNcbiAgICogY2FsbGVkLlxuICAgKi9cbiAgZXhwb3J0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgYXV0b21hdGljIGFsbG9jYXRpb24gb2YgYW4gZXhwb3J0IG5hbWUgZm9yIHRoaXMgb3V0cHV0LlxuICAgKlxuICAgKiBUaGlzIHByb2hpYml0cyBleHBvcnRpbmcgdGhpcyB2YWx1ZSwgZWl0aGVyIGJ5IHNwZWNpZnlpbmcgYGV4cG9ydGAgb3JcbiAgICogYnkgY2FsbGluZyBgbWFrZUltcG9ydFZhbHVlKClgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUV4cG9ydD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgY29uZGl0aW9uIGZyb20gdGhlIFwiQ29uZGl0aW9uc1wiIHNlY3Rpb24gdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBvdXRwdXRcbiAgICogdmFsdWUuIElmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGBmYWxzZWAsIHRoaXMgb3V0cHV0IHZhbHVlIHdpbGwgbm90XG4gICAqIGJlIGluY2x1ZGVkIGluIHRoZSBzdGFjay5cbiAgICovXG4gIGNvbmRpdGlvbj86IENvbmRpdGlvbjtcbn1cblxuZXhwb3J0IGNsYXNzIE91dHB1dCBleHRlbmRzIFN0YWNrRWxlbWVudCB7XG4gIC8qKlxuICAgKiBBIFN0cmluZyB0eXBlIHRoYXQgZGVzY3JpYmVzIHRoZSBvdXRwdXQgdmFsdWUuXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBjYW4gYmUgYSBtYXhpbXVtIG9mIDQgSyBpbiBsZW5ndGguXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSBvdXRwdXQgdG8gYmUgZXhwb3J0ZWQgZm9yIGEgY3Jvc3Mtc3RhY2sgcmVmZXJlbmNlLlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgbG9naWNhbCBJRCBvZiB0aGUgT3V0cHV0IGVsZW1lbnQgaXMgdXNlZCBhcyBpdCdzIGV4cG9ydCBuYW1lLlxuICAgKlxuICAgKiBNYXkgYmUgdW5kZWZpbmVkIGlmIHRoZSBPdXRwdXQgaGFzbid0IGJlZW4gZXhwb3J0ZWQgeWV0LlxuICAgKi9cbiAgcHVibGljIGV4cG9ydD86IHN0cmluZztcblxuICAvKipcbiAgICogQSBjb25kaXRpb24gZnJvbSB0aGUgXCJDb25kaXRpb25zXCIgc2VjdGlvbiB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG91dHB1dFxuICAgKiB2YWx1ZS4gSWYgdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gYGZhbHNlYCwgdGhpcyBvdXRwdXQgdmFsdWUgd2lsbCBub3RcbiAgICogYmUgaW5jbHVkZWQgaW4gdGhlIHN0YWNrLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNvbmRpdGlvbj86IENvbmRpdGlvbjtcblxuICBwcml2YXRlIF92YWx1ZT86IGFueTtcblxuICBwcml2YXRlIGRpc2FibGVFeHBvcnQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT3V0cHV0IHZhbHVlIGZvciB0aGlzIHN0YWNrLlxuICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgY29uc3RydWN0LlxuICAgKiBAcGFyYW0gcHJvcHMgT3V0cHV0IHByb3BlcnRpZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogT3V0cHV0UHJvcHMgPSB7fSkge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gcHJvcHMuZGVzY3JpcHRpb247XG4gICAgdGhpcy5fdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB0aGlzLmNvbmRpdGlvbiA9IHByb3BzLmNvbmRpdGlvbjtcblxuICAgIHRoaXMuZGlzYWJsZUV4cG9ydCA9IHByb3BzLmRpc2FibGVFeHBvcnQgIT09IHVuZGVmaW5lZCA/IHByb3BzLmRpc2FibGVFeHBvcnQgOiBmYWxzZTtcblxuICAgIGlmIChwcm9wcy5leHBvcnQgJiYgdGhpcy5kaXNhYmxlRXhwb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgYGRpc2FibGVFeHBvcnRgIGFuZCBzcGVjaWZ5IGFuIGV4cG9ydCBuYW1lJyk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBvcnQgPSBwcm9wcy5leHBvcnQ7XG5cbiAgICBpZiAocHJvcHMuZXhwb3J0KSB7XG4gICAgICB0aGlzLmV4cG9ydCA9IHByb3BzLmV4cG9ydDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSByZXR1cm5lZCBieSB0aGUgYXdzIGNsb3VkZm9ybWF0aW9uIGRlc2NyaWJlLXN0YWNrcyBjb21tYW5kLlxuICAgKiBUaGUgdmFsdWUgb2YgYW4gb3V0cHV0IGNhbiBpbmNsdWRlIGxpdGVyYWxzLCBwYXJhbWV0ZXIgcmVmZXJlbmNlcywgcHNldWRvLXBhcmFtZXRlcnMsXG4gICAqIGEgbWFwcGluZyB2YWx1ZSwgb3IgaW50cmluc2ljIGZ1bmN0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBnZXQgdmFsdWUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBGbkltcG9ydFZhbHVlIGJvdW5kIHRvIHRoaXMgZXhwb3J0IG5hbWUuXG4gICAqL1xuICBwdWJsaWMgbWFrZUltcG9ydFZhbHVlKCkge1xuICAgIHJldHVybiBmbigpLmltcG9ydFZhbHVlKHRoaXMub2J0YWluRXhwb3J0TmFtZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyB0b0Nsb3VkRm9ybWF0aW9uKCk6IG9iamVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE91dHB1dHM6IHtcbiAgICAgICAgW3RoaXMubG9naWNhbElkXToge1xuICAgICAgICAgIERlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIFZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgIEV4cG9ydDogdGhpcy5leHBvcnQgIT0gbnVsbCA/IHsgTmFtZTogdGhpcy5leHBvcnQgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBDb25kaXRpb246IHRoaXMuY29uZGl0aW9uID8gdGhpcy5jb25kaXRpb24ubG9naWNhbElkIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGdldCByZWYoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dHMgY2Fubm90IGJlIHJlZmVyZW5jZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvY2F0ZSBhbiBleHBvcnQgbmFtZSBmb3IgdGhpcyBgT3V0cHV0YCBpZiBub3QgYWxyZWFkeSBkb25lLlxuICAgKi9cbiAgcHVibGljIG9idGFpbkV4cG9ydE5hbWUoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuZXhwb3J0ICYmIHRoaXMuZGlzYWJsZUV4cG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGFuIEltcG9ydFZhbHVlOyBgZGlzYWJsZUV4cG9ydGAgaGFzIGJlZW4gc2V0LicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZXhwb3J0KSB7XG4gICAgICB0aGlzLmV4cG9ydCA9IHRoaXMudW5pcXVlT3V0cHV0TmFtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBvcnQ7XG4gIH1cblxuICAvKipcbiAgICogQXV0b21hdGljYWxseSBkZXRlcm1pbmUgYW4gb3V0cHV0IG5hbWUgZm9yIHVzZSB3aXRoIEZuSW1wb3J0VmFsdWVcbiAgICpcbiAgICogVGhpcyBnZXRzIGNhbGxlZCBpbiBjYXNlIHRoZSB1c2VyIGhhc24ndCBzcGVjaWZpZWQgYW4gZXhwb3J0IG5hbWUgYnV0IGlzXG4gICAqIHRha2luZyBhbiBhY3Rpb24gdGhhdCByZXF1aXJlcyBleHBvcnRpbmcuIFdlIG5hbWVzcGFjZSB3aXRoIHRoZSBzdGFjayBuYW1lXG4gICAqIHRvIHJlZHVjZSBjaGFuY2VzIG9mIGNvbGxpc3Npb25zIGJldHdlZW4gQ0RLIGFwcHMuXG4gICAqL1xuICBwcml2YXRlIHVuaXF1ZU91dHB1dE5hbWUoKSB7XG4gICAgLy8gcHJlZml4IGV4cG9ydCBuYW1lIHdpdGggc3RhY2sgbmFtZSBzaW5jZSBleHBvcnRzIGFyZSBnbG9iYWwgd2l0aGluIGFjY291bnQgKyByZWdpb24uXG4gICAgY29uc3Qgc3RhY2tOYW1lID0gdGhpcy5ub2RlLnN0YWNrLm5hbWU7XG4gICAgcmV0dXJuIChzdGFja05hbWUgPyBzdGFja05hbWUgKyAnOicgOiAnJykgKyB0aGlzLmxvZ2ljYWxJZDtcbiAgfVxufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIExpc3RPdXRwdXRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJpbmdMaXN0T3V0cHV0UHJvcHMge1xuICAvKipcbiAgICogQSBTdHJpbmcgdHlwZSB0aGF0IGRlc2NyaWJlcyB0aGUgb3V0cHV0IHZhbHVlLlxuICAgKiBUaGUgZGVzY3JpcHRpb24gY2FuIGJlIGEgbWF4aW11bSBvZiA0IEsgaW4gbGVuZ3RoLlxuICAgKi9cbiAgcmVhZG9ubHkgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHByaW1pdGl2ZXMgdG8gZXhwb3J0XG4gICAqL1xuICByZWFkb25seSB2YWx1ZXM6IGFueVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VwYXJhdG9yIHRvIHVzZSB0byBzZXBhcmF0ZSBzdHJpbmdpZmllZCB2YWx1ZXNcbiAgICpcbiAgICogQGRlZmF1bHQgXCIsXCJcbiAgICovXG4gIHJlYWRvbmx5IHNlcGFyYXRvcj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgdXNlZCB0byBleHBvcnQgdGhlIHZhbHVlIG9mIHRoaXMgb3V0cHV0IGFjcm9zcyBzdGFja3MuIFRvIGltcG9ydFxuICAgKiB0aGUgdmFsdWUgZnJvbSBhbm90aGVyIHN0YWNrLCB1c2UgYEZuSW1wb3J0VmFsdWUoZXhwb3J0KWAuIFlvdSBjYW4gY3JlYXRlXG4gICAqIGFuIGltcG9ydCB2YWx1ZSB0b2tlbiBieSBjYWxsaW5nIGBvdXRwdXQubWFrZUltcG9ydFZhbHVlKClgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBhdXRvbWF0aWNhbGx5IGFsbG9jYXRlIGFuIGV4cG9ydCBuYW1lXG4gICAqIGZvciBvdXRwdXRzIGJhc2VkIG9uIHRoZSBzdGFjayBuYW1lIGFuZCB0aGUgb3V0cHV0J3MgbG9naWNhbCBJRC4gVG9cbiAgICogY3JlYXRlIGFuIG91dHB1dCB3aXRob3V0IGFuIGV4cG9ydCwgc2V0IGBkaXNhYmxlRXhwb3J0OiB0cnVlYC5cbiAgICovXG4gIHJlYWRvbmx5IGV4cG9ydD86IHN0cmluZztcblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGF1dG9tYXRpYyBhbGxvY2F0aW9uIG9mIGFuIGV4cG9ydCBuYW1lIGZvciB0aGlzIG91dHB1dC5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2UsIHdoaWNoIG1lYW5zIHRoYXQgYW4gZXhwb3J0IG5hbWUgaXMgZWl0aGVyIGV4cGxpY2l0bHlcbiAgICogc3BlY2lmaWVkIG9yIGFsbG9jYXRlZCBiYXNlZCBvbiB0aGUgb3V0cHV0J3MgbG9naWNhbCBJRCBhbmQgc3RhY2sgbmFtZS5cbiAgICovXG4gIHJlYWRvbmx5IGRpc2FibGVFeHBvcnQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGNvbmRpdGlvbiBmcm9tIHRoZSBcIkNvbmRpdGlvbnNcIiBzZWN0aW9uIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgb3V0cHV0XG4gICAqIHZhbHVlLiBJZiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBgZmFsc2VgLCB0aGlzIG91dHB1dCB2YWx1ZSB3aWxsIG5vdFxuICAgKiBiZSBpbmNsdWRlZCBpbiB0aGUgc3RhY2suXG4gICAqL1xuICByZWFkb25seSBjb25kaXRpb24/OiBDb25kaXRpb247XG59XG5cbi8qKlxuICogQW4gb3V0cHV0IGZvciBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqXG4gKiBFeHBvcnRzIGEgbGlzdCBvZiBUb2tlbnMgdmlhIGFuIE91dHB1dCB2YXJpYWJsZSwgYW5kIHJldHVybiBhIGxpc3Qgb2YgVG9rZW5zXG4gKiB0aGF0IHNlbGVjdHMgdGhlIGltcG9ydGVkIHZhbHVlcyBmb3IgdGhlbS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0xpc3RPdXRwdXQgZXh0ZW5kcyBDb25zdHJ1Y3Qge1xuICAvKipcbiAgICogTnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzdHJpbmdsaXN0XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbGVuZ3RoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXBhcmF0b3IgdXNlZCB0byBjb21iaW5lIHRoZSBzdHJpbmcgdmFsdWVzXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHNlcGFyYXRvcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgT3V0cHV0IG9iamVjdCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dDogT3V0cHV0O1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBTdHJpbmdMaXN0T3V0cHV0UHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5zZXBhcmF0b3IgPSBwcm9wcy5zZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMubGVuZ3RoID0gcHJvcHMudmFsdWVzLmxlbmd0aDtcblxuICAgIHRoaXMub3V0cHV0ID0gbmV3IE91dHB1dCh0aGlzLCAnUmVzb3VyY2UnLCB7XG4gICAgICBkZXNjcmlwdGlvbjogcHJvcHMuZGVzY3JpcHRpb24sXG4gICAgICBjb25kaXRpb246IHByb3BzLmNvbmRpdGlvbixcbiAgICAgIGRpc2FibGVFeHBvcnQ6IHByb3BzLmRpc2FibGVFeHBvcnQsXG4gICAgICBleHBvcnQ6IHByb3BzLmV4cG9ydCxcbiAgICAgIHZhbHVlOiBmbigpLmpvaW4odGhpcy5zZXBhcmF0b3IsIHByb3BzLnZhbHVlcylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgaW1wb3J0ZWQgdmFsdWVzIGZvciB0aGlzIE91dHB1dFxuICAgKi9cbiAgcHVibGljIG1ha2VJbXBvcnRWYWx1ZXMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGNvbWJpbmVkID0gdGhpcy5vdXRwdXQubWFrZUltcG9ydFZhbHVlKCk7XG5cbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKGZuKCkuc2VsZWN0KGksIGZuKCkuc3BsaXQodGhpcy5zZXBhcmF0b3IsIGNvbWJpbmVkKSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm4oKSB7XG4gIC8vIExhenkgbG9hZGluZyBvZiBcIkZuXCIgbW9kdWxlIHRvIGJyZWFrIGRlcGVuZGVuY3kgY3ljbGVzIG9uIHN0YXJ0dXBcbiAgcmV0dXJuIHJlcXVpcmUoJy4vZm4nKS5Gbjtcbn1cblxuaW1wb3J0IHsgQ29uZGl0aW9uIH0gZnJvbSAnLi9jb25kaXRpb24nO1xuIl19