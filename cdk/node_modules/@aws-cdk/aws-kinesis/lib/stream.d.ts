import iam = require('@aws-cdk/aws-iam');
import kms = require('@aws-cdk/aws-kms');
import logs = require('@aws-cdk/aws-logs');
import cdk = require('@aws-cdk/cdk');
export interface IStream extends cdk.IConstruct, logs.ILogSubscriptionDestination {
    /**
     * The ARN of the stream.
     */
    readonly streamArn: string;
    /**
     * The name of the stream
     */
    readonly streamName: string;
    /**
     * Optional KMS encryption key associated with this stream.
     */
    readonly encryptionKey?: kms.IEncryptionKey;
    /**
     * Exports this stream from the stack.
     */
    export(): StreamImportProps;
    /**
     * Grant read permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to decrypt the
     * contents of the stream will also be granted.
     */
    grantRead(identity?: iam.IPrincipal): void;
    /**
     * Grant write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to encrypt the
     * contents of the stream will also be granted.
     */
    grantWrite(identity?: iam.IPrincipal): void;
    /**
     * Grants read/write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to use the key for
     * encrypt/decrypt will also be granted.
     */
    grantReadWrite(identity?: iam.IPrincipal): void;
}
/**
 * A reference to a stream. The easiest way to instantiate is to call
 * `stream.export()`. Then, the consumer can use `Stream.import(this, ref)` and
 * get a `Stream`.
 */
export interface StreamImportProps {
    /**
     * The ARN of the stream.
     */
    streamArn: string;
    /**
     * The KMS key securing the contents of the stream if encryption is enabled.
     */
    encryptionKey?: kms.EncryptionKeyImportProps;
}
/**
 * Represents a Kinesis Stream.
 *
 * Streams can be either defined within this stack:
 *
 *   new Stream(this, 'MyStream', { props });
 *
 * Or imported from an existing stream:
 *
 *   Stream.import(this, 'MyImportedStream', { streamArn: ... });
 *
 * You can also export a stream and import it into another stack:
 *
 *   const ref = myStream.export();
 *   Stream.import(this, 'MyImportedStream', ref);
 *
 */
export declare abstract class StreamBase extends cdk.Construct implements IStream {
    /**
     * The ARN of the stream.
     */
    abstract readonly streamArn: string;
    /**
     * The name of the stream
     */
    abstract readonly streamName: string;
    /**
     * Optional KMS encryption key associated with this stream.
     */
    abstract readonly encryptionKey?: kms.IEncryptionKey;
    /**
     * The role that can be used by CloudWatch logs to write to this stream
     */
    private cloudWatchLogsRole?;
    abstract export(): StreamImportProps;
    /**
     * Grant write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to decrypt the
     * contents of the stream will also be granted.
     */
    grantRead(identity?: iam.IPrincipal): void;
    /**
     * Grant read permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to decrypt the
     * contents of the stream will also be granted.
     */
    grantWrite(identity?: iam.IPrincipal): void;
    /**
     * Grants read/write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to use the key for
     * encrypt/decrypt will also be granted.
     */
    grantReadWrite(identity?: iam.IPrincipal): void;
    logSubscriptionDestination(sourceLogGroup: logs.ILogGroup): logs.LogSubscriptionDestination;
    /**
     * Generate a CloudWatch Logs Destination and return the properties in the form o a subscription destination
     */
    private crossAccountLogSubscriptionDestination;
    private grant;
}
export interface StreamProps {
    /**
     * Enforces a particular physical stream name.
     * @default <generated>
     */
    streamName?: string;
    /**
     * The number of hours for the data records that are stored in shards to remain accessible.
     * @default 24
     */
    retentionPeriodHours?: number;
    /**
     * The number of shards for the stream.
     * @default 1
     */
    shardCount?: number;
    /**
     * The kind of server-side encryption to apply to this stream.
     *
     * If you choose KMS, you can specify a KMS key via `encryptionKey`. If
     * encryption key is not specified, a key will automatically be created.
     *
     * @default Unencrypted
     */
    encryption?: StreamEncryption;
    /**
     * External KMS key to use for stream encryption.
     *
     * The 'encryption' property must be set to "Kms".
     *
     * @default If encryption is set to "Kms" and this property is undefined, a
     * new KMS key will be created and associated with this stream.
     */
    encryptionKey?: kms.IEncryptionKey;
}
/**
 * A Kinesis stream. Can be encrypted with a KMS key.
 */
export declare class Stream extends StreamBase {
    /**
     * Creates a Stream construct that represents an external stream.
     *
     * @param scope The parent creating construct (usually `this`).
     * @param id The construct's name.
     * @param ref A `StreamAttributes` object. Can be obtained from a call to
     * `stream.export()`.
     */
    static import(scope: cdk.Construct, id: string, props: StreamImportProps): IStream;
    readonly streamArn: string;
    readonly streamName: string;
    readonly encryptionKey?: kms.IEncryptionKey;
    private readonly stream;
    constructor(scope: cdk.Construct, id: string, props?: StreamProps);
    /**
     * Exports this stream from the stack.
     */
    export(): StreamImportProps;
    /**
     * Set up key properties and return the Stream encryption property from the
     * user's configuration.
     */
    private parseEncryption;
}
/**
 * What kind of server-side encryption to apply to this stream
 */
export declare enum StreamEncryption {
    /**
     * Records in the stream are not encrypted.
     */
    Unencrypted = "NONE",
    /**
     * Server-side encryption with a KMS key managed by the user.
     * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.
     */
    Kms = "KMS"
}
